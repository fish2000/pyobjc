=========================
An introduction to PyObjC
=========================

..	:authors: Ronald Oussoren
	:contact: pyobjc-dev@lists.sourceforge.net
	:URL: http://pyobjc.sourceforge.net/
	:copyright: 2003 The PyObjC Project



.. contents::

WORK IN PROGRESS
----------------

This document is work in progress and thin on details.


Preface
-------

PyObjC is a bridge between Python and Objective-C. It allows you to write 
Python scripts that use and extend existing Objective-C class libraries, 
most importantly the `Cocoa libraries`_ by `Apple`_.

This document describes how to use Objective-C class libraries from Python
scripts and how to interpret the documentation of those libraries, from the 
point of view of a Python programmer.

.. _`Apple`: http://www.apple.com/

Objective-C for PyObjC users
----------------------------

Objective-C is an object-oriented programming language that is an extension 
of C and borrows heavily from Smalltalk. It features single inheritance with
(in theory) multiple root classes and dynamic dispatch of methods. This is
basicly the same as Python with single inheritance.

An important difference between Python and Objective-C is that the latter is
not a pure object-oriented language. Some values are not objects, but values
of plain C types, such as ``int`` and ``double``. These basic C types can also
be used as the types of arguments and the return value of methods. 

Object allocation and initialization are explicit and seperate actions in 
Objective-C. The former is done by the class-method ``alloc``, while the
latter is done by instance-methods whose name customarily starts with ``init``.

For more information about Objective-C see:

* `The Objective-C Programming Language`_ at `Apple`_.

.. _`The Objective-C Programming Language`: http://developer.apple.com/techpubs/macosx/Cocoa/ObjectiveC/index.html


Overview of the bridge
----------------------

Objective-C classes are visible as Python classes and can be subclassed just
like normal Python classes. The major differences between normal Python classes
and Objective-C classes are the way you create instances and the fact that 
Objective-C classes have odd names.

As described in `Objective-C for PyObjC users`_ the creation of Objective-C 
objects is a two-stage process. You first call the class method ``alloc``, and
then call some variation of ``init`` to initialize the objects. The newly
created object is the result of the call to ``init``. Most classes have 
convienence class methods that combine the calls to ``alloc`` and ``init``.

Objective-C methods are bridged to Python callables. Because Objective-C method 
names can contain colons it is necessary to translate methods names. The rules
for translation are:

* Concatenate all elements of the method name: ``someMethod:withFoo:andBar:``

* Then convert all colons to underscores: ``someMethod_withFoo_andBar_``

The bridged method usually has the same number of arguments as the orginal 
method and also returns the same as the original method. In special 
circumstances the method interface may be different from the Objective-C 
interface, those methods are document in 'some other document'. Furthermore,
some methods have pass-by-reference arguments (that is a pointer to a single
value that is used to transfer data to (in), from (out) or to-and-from (inout)
the method. The arguments that are passed to methods is present as normal 
arguments in the bridged method (e.g. if the method has an ``int*`` argument
the bridged method has has an integer argument).  Data that is passed from the
function results in additional return values from the function.

When the bridge cannot automaticly deduce the right signature for a method, or
if you want to add a method whose name cannot be transformed into Python (
for example a methodname containing ``$``), you'll have to add explicit hints
to your code. You do this by calling the function ``objc.selector`` and using
the result instead of your method definition::

	class MyObject (NSObject):
		def someMethod_(self, arg):
			pass

		someMethod_ = objc.selector(someMethod_, ...)

The other arguments of ``objc.selector`` (not shown in the example) provide
additional information about the method to the bridge, see the online 
documentation for more information about this function. It is almost never
necessary to use this technique.

If you write a method for an Objecitve-C class in Python, PyObjC will try to
deduce the method's signature. If it's overriding a method, the signature of
the method that is overridden is taken. If it's a method that appears
*anywhere* in an informal protocol definition in a framework that's currently
loaded, PyObjC takes the signature from there. (Most wrapped frameworks have a
submodule named ``protocols.py`` that contains informal protocol definitions.)


Cocoa for Python programmers
----------------------------

Cocoa frameworks are mapped onto Python packages with the same name, that is
the classes, constants and functioins from the AppKit framework are available
after you import ``AppKit`` in your Python script.

The module ``PyObjCTools.NibClassBuilder`` can be used to make working with 
NIB files more convenient. This module can be used to extract information 
about classes from NIB files, both as a standalone tool generating source code 
and during runtime. See the online documentation for this module for more
information.

**TODO**:

* Links to example PyObjC scripts.


More information on Cocoa programming can be found at:

* `Cocoa documentation at the Apple developer website`_

* `Cocoa examples at the Apple developer website`_

* `stepwise.com`_

* Your local bookstore or library

..  _`Cocoa libraries`: http://developer.apple.com/techpubs/macosx/Cocoa/CocoaTopics.html

..  _`Cocoa documentation at the Apple developer website`: http://developer.apple.com/techpubs/macosx/Cocoa/CocoaTopics.html

.. _`Cocoa examples at the Apple developer website`: http://developer.apple.com/samplecode/Sample_Code/Cocoa.htm

.. _`stepwise.com`: http://www.stepwise.com/


Building applications
---------------------

There are two different ways to build applications with PyObjC. There are no
major advantages to using either one of them, use the one that is most 
convenient to you.

"Pure Python" :  buildapp.py
............................

PyObjC includes a copy of the ``bundlebuilder`` module. This module will be
part of the Python 2.3 MacPython release and offers a way to build
distutil-style scripts  for building (standalone) applications.

An example ``buildapp.py`` script::

	from bundlebuilder import buildapp
	buildapp(
		name = 'iClass',
		mainprogram = "main.py",
		resources = ["English.lproj", "datasource.py" ],
		nibname = "MainMenu",
	)   

During development you typically invoke it from the command line like this::

	python buildapp.py --link build

This will build an application bundle in a folder named ``build`` in the
current folder. The ``--link`` option tells ``bundlebuilder`` to add symbolic
links to the application bundle instead of copies of your source and resource
files, allowing you to edit them without having to rebuild the application. To
build a standalone application, either use ``--standalone`` or
``--semi-standalone``. The latter will put all used modules that are not in
Python's standard library into the application bundle. The result will still
depend on an installed Python, but yields a relatively compact application.
``--standalone`` will cause ``bundlebuilder`` to include *everything* needed
into the app bundle, including the entire Python runtime. This is useful if
you're using a different version of Python that the one that comes with MacOSX
10.2, or if you fear that a future version of OSX may come with an
incompatible Python version.

The online documentation for ``bundlebuilder`` contains more information on 
building ``buildapp.py`` scripts and how to invoke them. There are plenty of
example ``buildapp.py`` scripts in the various `Examples`__ subfolders.

.. __: ../Examples


"IDE approach" : Project builder
................................

PyObjC includes a number of Project Builder templates that can be used to 
build (standalone) applications.

**TODO**:

* Expand this section, input needed as I don't use Project Builder

* Add link to documentation about our templates

* Add link to documentation for Project Builder

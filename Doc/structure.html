<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
Structure of the PyObjC package</title>
</head>
<body>
<h2>Structure of the PyObjC package</h2>
<h2><a name="introduction">Introduction</a></h2>
<p>This document gives an overview of the PyObjC for developers (of the package).</p>
<p>One of the sections describes how all of it works, and some of the limitations.</p>
<p>This document is a incomplete, it should be updated.</p>
<h2><a name="methods">Methods</a></h2>
<p>Classes are scanned for methods when the Python wrapper for a class is created.
We then create Python wrappers for those methods. This way users can use the
normal Python introspection methods to check which methods are available.</p>
<p>There are several occasions when these method tables are rescanned, because
classes can grow new methods when categories are loaded into the runtime.
Additionally, it is known that some Cocoa frameworks in Mac OS X change
their method tables when the first instance is created.</p>
<h2><a name="subclassing">Subclassing</a></h2>
<p>It is possible to subclass Objective-C classes from Python.  These classes
end up in a structure containing both a Python type object and an Objective-C
class.  Instances of these classes also contain both a Python instance and
an Objective-C object.</p>
<p>The first Python subclass of an Objective-C class introduces a new instance
variable in the Objective-C object to store the pointer to the Python half of
the cluster.  This variable is always referenced by name.  The Python half is 
a subclass of objc_object that already contains a pointer to an Objective-C 
object.  This first subclass also introduces a number of class and instance
methods that the PyObjC bridge uses to maintain the illusion of a single
object on both sides.  Check class-builder.m for details.</p>
<h2><a name="directory-structure">Directory structure</a></h2>
<dl>
<dt>Doc/</dt>
<dd><p>Documentation</p>
</dd>
<dt>Examples/</dt>
<dd><p>Example scripts and applets.</p>
</dd>
<dt>Lib/</dt>
<dd><p>The pure Python parts of the packages that comprise PyObjC.  Currently
contains the packages 'objc', 'PyObjCScripts', 'PyObjCTools' and the
semi-automatically generated wrappers for the 'AddressBook',
'AppKit', 'ExceptionHandling', 'Foundation', 'InterfaceBuilder', 'Message',
'PreferencePanes', 'ScreenSaver', 'SecurityInterface' and 'WebKit'
frameworks.</p>
</dd>
<dt>Modules/</dt>
<dd><p>Extension modules related to the packages in 'Lib'.</p>
</dd>
<dt>Scripts/</dt>
<dd><p>Scripts used during building and/or development of PyObjC.</p>
</dd>
<dt>Installer Package/</dt>
<dd><p>Resources used for building the Apple Installer packages.</p>
</dd>
<dt>ProjectBuilder Extras/</dt>
<dd><p>Project Builder templates and syntax specifications for PyObjC development.</p>
</dd>
<dt>Xcode/</dt>
<dd><p>Xcode templates for PyObjC development.</p>
</dd>
<dt>libffi-src/</dt>
<dd><p>A local copy of libffi, the Foreign Function Interface library used by
PyObjC.</p>
</dd>
<dt>setup-lib/</dt>
<dd><p>Modules used by setup.py for building and distributing PyObjC.</p>
</dd>
<dt>source-deps/</dt>
<dd><p>Local copies of Python packages and modules used by PyObjC that are not
expected to be found in the minimum supported version of Python.  These
are not automatically installed by setup.py, but some may be included in
a bdist_mpkg installer (currently, just py2app).</p>
</dd>
</dl>
<h2><a name="reference-counts">Reference counts</a></h2>
<p>The Objective-C rules for reference counts are pretty easy: A small number
of class methods (alloc, allocWithZone:, copy, ...) transfer object ownership
to the caller.  For all other objects you have to call 'retain' if you want
to keep a reference.  This includes all factory methods (e.g. 
[NSString stringWithCString:&quot;bla&quot;])!</p>
<p>When programming Cocoa in Python, you rarely need to worry about
reference counts: the objc module makes this completely transparent to user.
This is mostly implemented in [de]pythonify_c_value. Additonal code is needed
when calling methods that transfer ownership of their return value (as
described above) and when updating a instance variable in an Objective-C
object (retain new and release old, in that order). Both are implemented.</p>
<h2><a name="strings">Strings</a></h2>
<p>Python unicode instances are automatically converted to NSString and
back. An NSString is represented in Python as a subclass of the 'unicode'
class: objc.pyobjc_unicode.  This is a conversion, because Python's unicode
type is immutable, but it also maintains a <i>reference</i> to the original
NSString.  Currently, the conversion is done using UTF-8 for exchange,
because unicode's internal representation may be changed with a compile
time flag.</p>
<p>The original, unwrapped, NSString instance is accessible from Python
with the .nsstring() method of objc.pyobjc_unicode, mostly for creating an
updated copy of an NSMutableString's contents.  Since PyObjC 1.2,
NSString and NSMutableString methods are available from the objc.pyobjc_unicode
object, though they do not show up via Python's introspection mechanisms.</p>
<p>For legacy and convenience, Python str instances are automatically coerced
into unicode when they cross the bridge using the same mechanism that
automatically converts from str to unicode (using 
<code><span>sys.getdefaultencoding()</span></code>).  This automatic conversion can cause terrible
things to happen at runtime that are hard to test for, so you may enable an
<code><span>objc.PyObjCStrBridgeWarning</span></code> at each coercion by calling
<code><span>objc.setStrBridgeEnabled(False)</span></code>.  To promote this warning to an exception,
see the documentation for the <code><span>warnings</span></code> module in the standard library.</p>
</body>
</html>

TODO's for the 3.0 branch
=========================

Short term
----------

* Better tests for the new C code, especially:

  - lookup of selectors like 'prefix_suffixCanDo:withObject:' (with an embedded underscore)
    test if a subclass version is found when the superclass version is already in __dict__.

  - test_methodlookup might not yet test all relevant code paths

* Code cleanup for the new C code, I've done too much copy&paste editing
  while getting the new code to work properly.

* Lib/objc/_convenience.py cleanup:

  - Remove all _CONVENIENCE_METHODS, as well as functions that aren't used anymore

  - Move bits of _convenience.py to the right framework wrapper

* Issue #29: Move some Foundation helpers to core

  This helps in keeping pyobjc-core usable without framework wrappers, and the core
  has intimate knowledge about these types anyway for implementing the OC_* classes.

  - convenience helpers for NSArray, NSData, NSDictionary, NSSet need to be in core
  - likewise for mutable versions
  - likewise for their C helpers (partially done for NSData)

* Create and run performance tests to check if new code is faster than the 2.x branch

  - check if it is useful to cache method name lookup in subclasses as well (that is,
    when looking for a method in a subclass and that method is found in a superclass
    add it to the subclass dict as well, with a flag mentioning that this is a cache
    entry). 
    
    This avoids hitting the runtime when calling methods that are defined in a superclass,
    and could be more efficient. Needs care to avoid problems with objc.super though.

    note: no need to care for __builtin__.super support here, that super wont work
    with Cocoa classes anyway (already true in 2.x, and more glaringly so in 3.0)

* Issue #25: issue the 'protocols' submodule on framework wrappers (e.g. Foundation.protocols)

* Attribute lookup converts name to bytestring and that to a SEL. For python 3.3 we can
  shortcut this: selectors must be all ascii, hence we could just check that the unicode
  object has the ascii representation and then directly access the UCS1 buffer instead
  of converting to a bytes object first. This should slightly improve performance.


Medium term
-----------

* All symbols that are available on 10.5 or later should be weak linked using the new
  macros in pyobjc-api.h. See <https://bitbucket.org/ronaldoussoren/pyobjc/issue/46/deployment-issue-in-coregraphics>
  for the reason for this.

  This shouldn't result in a lot more code, and could even make manual wrappers slightly
  shorter.

* Loading a framework takes too much time, why?

* Look for a more efficient encoding of _metadata.py, possibly using a C exension

* Look for a more efficient encoding of method metadata registry (the data
  structure maintained by ``objc.registerMetaDataForSelector``)

* Try adding support for ARC runtime functions (to avoid hitting
  the autorelease pool on systems using ARC)

  - Add explict preprocessor test and #error line to ensure 
    PyObjC itself isn't compiled with ARC enabled.

  - Basically try to create a variant of the libffi assembly code
    for x86_64 that calls objc_retainAutoreleasedReturnValue on the
    result and use that instead of the regular assembly unless
    the method returns an 'already_retained' value (and adjust
    libffi-support code to deal with this).

    Note: code changes should be done carefully to ensure PyObjC still works
    on older OSX releases that don't support ARC (10.6 and earlier and
    32-bit binaries)

* Remove use of CFRetain/CFRelease, use regular -retain/-release messages
  instead (or even 'objc_retain/objc_release)'

* Tweak __name__ and __qualname__ for convenience functions/methods for nicer
  pydoc output.

* Add __signature__ to objc.selector and objc.function (see inspect.signature)

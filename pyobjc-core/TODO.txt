TODO's for the 3.0 branch
=========================

Short term
----------

* Better tests for the new C code, especially:

  - lookup of selectors like 'prefix_suffixCanDo:withObject:' (with an embedded underscore)
    test if a subclass version is found when the superclass version is already in __dict__.

  - test_methodlookup might not yet test all relevant code paths

* Code cleanup for the new C code, I've done too much copy&paste editing
  while getting the new code to work properly.

* Calling methods is slower than expected, create better performance tests and try
  to optimize (for example by creating a shortcut variant that doesn't handle
  "hard" methods).

* Lib/objc/_convenience.py cleanup:

  - Remove all _CONVENIENCE_METHODS, as well as functions that aren't used anymore

  - Move bits of _convenience.py to the right framework wrapper

* Issue #29: Move some Foundation helpers to core

  This helps in keeping pyobjc-core usable without framework wrappers, and the core
  has intimate knowledge about these types anyway for implementing the OC_* classes.

  - convenience helpers for NSArray, NSData, NSDictionary, NSSet need to be in core
  - likewise for mutable versions
  - likewise for their C helpers (partially done for NSData)

* Create and run performance tests to check if new code is faster than the 2.x branch

  - check if it is useful to cache method name lookup in subclasses as well (that is,
    when looking for a method in a subclass and that method is found in a superclass
    add it to the subclass dict as well, with a flag mentioning that this is a cache
    entry).

    This avoids hitting the runtime when calling methods that are defined in a superclass,
    and could be more efficient. Needs care to avoid problems with objc.super though.

    note: no need to care for __builtin__.super support here, that super wont work
    with Cocoa classes anyway (already true in 2.x, and more glaringly so in 3.0)

Medium term
-----------

* Loading a framework takes too much time, why?

  On my machine the first import is slow, subsequence imports are faster.

  This appears to primairly be disk I/O::

     $ for in in $(seq 20); do purge; python -c 'pass'; time python3 -c 'import Quartz'; done
     ...

     real	0m28.873s
     user	0m0.635s
     sys	0m0.169s

     ...

  These times were fairly consistent, the 'real' time fluctuated but around the 30
  second mark.

  The regular interpreter startup is much faster::

     $ for in in $(seq 5); do purge; python -c 'pass'; time python3 -c 'pass'; done

     real	0m3.504s
     user	0m0.068s
     sys	0m0.033s

     ...

  Again, the timing was consistent.

  It is likely possible to speed up the framework loading by reducing the amount of
  disk I/O.

  There is however some inherent overhead in loading just "objc":

      $ for in in $(seq 5); do purge; python -c 'pass'; time python3 -c 'import objc'; done

      real	0m16.866s
      user	0m0.255s
      sys	0m0.086s

      real	0m12.323s
      user	0m0.255s
      sys	0m0.057s

      real	0m9.325s
      user	0m0.252s
      sys	0m0.052s

  It might be possible to avoid part of this by using a smaller number of submodules for
  the objc package.



* Look for a more efficient encoding of _metadata.py, possibly using a C exension

* Look for a more efficient encoding of method metadata registry (the data
  structure maintained by ``objc.registerMetaDataForSelector``)

* Try adding support for ARC runtime functions (to avoid hitting
  the autorelease pool on systems using ARC)

  - Add explict preprocessor test and #error line to ensure
    PyObjC itself isn't compiled with ARC enabled.

  - Basically try to create a variant of the libffi assembly code
    for x86_64 that calls objc_retainAutoreleasedReturnValue on the
    result and use that instead of the regular assembly unless
    the method returns an 'already_retained' value (and adjust
    libffi-support code to deal with this).

    Note: code changes should be done carefully to ensure PyObjC still works
    on older OSX releases that don't support ARC (10.6 and earlier and
    32-bit binaries)

* Remove use of CFRetain/CFRelease, use regular -retain/-release messages
  instead (or even 'objc_retain/objc_release)'

* Add __signature__ to objc.selector and objc.function (see inspect.signature)

* PyList_GET_ITEM/PyTuple_GET_ITEM + usage without INCREF is unsafe when code
  might call back into python!

* The initWithCoder methods contain a large blob of shared code, move to
  a separate function

* Add tests to check that serializing list, tuple, unicode, str, ... (but not subtypes)
  results in an NSArchive/NSKeyedArchive that can be read back in a pure ObjC
  process (without PyObjC subclasses in the process)

  NOTE: might require further update to the serialization code

* #include -> #import (and remove include guards), alternatively cleanup
  include guards.

* See XXX in block-support.m: need some extra code to get the
  same block objects as emitted by recent Clang versions

* Remove 10.3 support from class-builder.m (KVOHackLevel.m)

* FIXME in classbuilder.m

* Remove 'volatile' where possible (almost everywhere)

* Scare XXX in corefoundation.m

* getattro for NSDecimal values seems dodgy

* Remove use of 'volatile'

* special_registry in supercall should be a dictionary
  (selector -> list of structs)

* Add testsuite for "difficult" calls through NSUndoManager (but first check docs
  and test in objc, calling methods with arbitrary pointer arguments likely
  won't work with NSUndoManager anyway)

* Is Selector_FindNative needed with the new lookup mechanism?
  (also check explict class/instance method lookup mechanism)

* Remove PyObjCUtil_Strdup, use regular strdup instead

* Add tests using NumPy/numarray (and check if those implement the memoryview interface)

* PyObjCObject_GetAttrString can be removed?

* Replace 'assert' calls by calls to 'PyObjC_Assert'

* Remove PyObjCPointer completely?

* Add objc.options object, instead of having a large set of
  functions to manipulate options.

  Simple python helper functions can provide backward compatiblity.


* From Cocoa-dev:
	NSArray *a = @[ @"$nill", @"$null", @"$nall" ];
	NSLog(@"%s NSKeyedArchiver archiving %@", __FUNCTION__, a);
	NSData *e = [ NSKeyedArchiver archivedDataWithRootObject: a ];
	NSArray *b = [ NSKeyedUnarchiver unarchiveObjectWithData: e ];
	NSLog(@"%s NSKeyedUnarchiver got %@", __FUNCTION__, b);
	/*NSKeyedArchiver archiving (
	 "$nill",
	 "$null",
	 "$nall"
	 )
	 NSKeyedUnarchiver got ()
	 **/

  That is, some strins don't archive properly? Work around this in
  OC_PythonUnicode's archiving support

* Add _named_int, _named_long, _named_float to lazy loader to get nicer
  repr/str for named constants.

  Problem: non-empty slots is not supported for type long

* Crash with -fcatch-undefined-behavior (see setup.py)

/*
 * WARNING: This is a generated file, do not change
 *
 * XXX: This file contains a number of manual fixups related to GNUstep
 *      support. Need to fix this!
 */
#ifdef OC_WITH_LIBFFI

#include <Python.h>
#include <objc/objc.h>
#ifndef GNU_RUNTIME
#include <objc/objc-runtime.h>
#endif
#include <Foundation/NSException.h>
#define PYOBJC_METHOD_STUB_IMPL
#include "pyobjc-api.h"
#include "objc_support.h"

int ObjC_RegisterStdStubs(struct pyobjc_api* api)
{
	return 0;
}

#else

#include <Python.h>
#include <objc/objc.h>
#ifndef GNU_RUNTIME
#include <objc/objc-runtime.h>
#endif
#include <Foundation/NSException.h>
#define PYOBJC_METHOD_STUB_IMPL
#include "pyobjc-api.h"
#include "objc_support.h"

static struct pyobjc_api* ObjC_API;
typedef int (*superfunc)(int);


/* signature: c@:@@ */
static char 
meth_imp_0(id self, SEL sel, id arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_0(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: @@:@i@ */
static id 
meth_imp_1(id self, SEL sel, id arg_2, int arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_1(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	int objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: i@:@@ */
static int 
meth_imp_2(id self, SEL sel, id arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_2(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: #0@4:8 */
static Class 
meth_imp_3(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	Class objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("#", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_3(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	Class objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (Class)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("#", &objc_retval);
	return v;
}


/* signature: #0@4:8@12 */
static Class 
meth_imp_4(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	Class objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("#", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_4(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	Class objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (Class)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("#", &objc_retval);
	return v;
}


/* signature: #0@4:8@12@16 */
static Class 
meth_imp_5(id self, SEL sel, id arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	Class objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("#", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_5(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	Class objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (Class)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("#", &objc_retval);
	return v;
}


/* signature: #0@4:8I12 */
static Class 
meth_imp_6(id self, SEL sel, unsigned int arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	Class objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("#", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_6(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	Class objc_retval;
	unsigned int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (Class)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("#", &objc_retval);
	return v;
}


/* signature: *0@4:8 */
static char* 
meth_imp_7(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char* objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("*", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_7(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char* objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (char*)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("*", &objc_retval);
	return v;
}


// Skipped complex signature: *0@4:8@12^I16
/* signature: 8@12o^@16 */
static id 
meth_imp_8(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(0);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_8(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != -2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(2);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("@", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		return result_list;
	}
}


/* signature: :0@4:8 */
static SEL 
meth_imp_9(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	SEL objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC(":", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_9(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	SEL objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (SEL)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython(":", &objc_retval);
	return v;
}


/* signature: :0@4:8@12 */
static SEL 
meth_imp_10(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	SEL objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC(":", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_10(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	SEL objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (SEL)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython(":", &objc_retval);
	return v;
}


/* signature: @0@4:8 */
static id 
meth_imp_11(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_11(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8#12 */
static id 
meth_imp_12(id self, SEL sel, Class arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("#", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_12(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	Class objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("#", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8#12@16@20:24 */
static id 
meth_imp_13(id self, SEL sel, Class arg_2, id arg_3, id arg_4, SEL arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("#", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_13(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	Class objc_arg2;
	id objc_arg3;
	id objc_arg4;
	SEL objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("#", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8*12 */
static id 
meth_imp_14(id self, SEL sel, char* arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_14(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	char* objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8*12*16 */
static id 
meth_imp_15(id self, SEL sel, char* arg_2, char* arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_15(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	char* objc_arg2;
	char* objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8*12*16*20*24*28c32 */
static id 
meth_imp_16(id self, SEL sel, char* arg_2, char* arg_3, char* arg_4, char* arg_5, char* arg_6, char arg_7)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(7);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_16(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	char* objc_arg2;
	char* objc_arg3;
	char* objc_arg4;
	char* objc_arg5;
	char* objc_arg6;
	char objc_arg7;
	struct objc_super super;

	if (PyTuple_Size(args) != 6) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8*12@16*20 */
static id 
meth_imp_17(id self, SEL sel, char* arg_2, id arg_3, char* arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_17(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	char* objc_arg2;
	id objc_arg3;
	char* objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8*12I16 */
static id 
meth_imp_18(id self, SEL sel, char* arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_18(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	char* objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8*12I16c20 */
static id 
meth_imp_19(id self, SEL sel, char* arg_2, unsigned int arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_19(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	char* objc_arg2;
	unsigned int objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8*12i16 */
static id 
meth_imp_20(id self, SEL sel, char* arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_20(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	char* objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8:12 */
static id 
meth_imp_21(id self, SEL sel, SEL arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_21(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	SEL objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8:12@16 */
static id 
meth_imp_22(id self, SEL sel, SEL arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_22(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	SEL objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8:12@16@20 */
static id 
meth_imp_23(id self, SEL sel, SEL arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_23(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	SEL objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @0@4:8:12@16^@20
// Skipped complex signature: @0@4:8:12^:16
// Skipped complex signature: @0@4:8:12^v16
/* signature: @0@4:8:12c16 */
static id 
meth_imp_24(id self, SEL sel, SEL arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_24(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	SEL objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8:12i16@20@24 */
static id 
meth_imp_25(id self, SEL sel, SEL arg_2, int arg_3, id arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_25(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	SEL objc_arg2;
	int objc_arg3;
	id objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8:12{_NSRange=II}16@24 */
#if 0 /* ndef GNUSTEP */
struct _NSRange {
	unsigned int field_0;
	unsigned int field_1;
};
#endif

static id 
meth_imp_26(id self, SEL sel, SEL arg_2, struct _NSRange arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_26(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	SEL objc_arg2;
	struct _NSRange objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12 */
static id 
meth_imp_27(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_27(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12#16 */
static id 
meth_imp_28(id self, SEL sel, id arg_2, Class arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("#", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_28(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	Class objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("#", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12*16 */
static id 
meth_imp_29(id self, SEL sel, id arg_2, char* arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_29(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	char* objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12:16 */
static id 
meth_imp_30(id self, SEL sel, id arg_2, SEL arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_30(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	SEL objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12:16@20 */
static id 
meth_imp_31(id self, SEL sel, id arg_2, SEL arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_31(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	SEL objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12:16@20i24 */
static id 
meth_imp_32(id self, SEL sel, id arg_2, SEL arg_3, id arg_4, int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_32(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	SEL objc_arg3;
	id objc_arg4;
	int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12:16i20 */
static id 
meth_imp_33(id self, SEL sel, id arg_2, SEL arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_33(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	SEL objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16 */
static id 
meth_imp_34(id self, SEL sel, id arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_34(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16*20 */
static id 
meth_imp_35(id self, SEL sel, id arg_2, id arg_3, char* arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_35(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	char* objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16:20@24 */
static id 
meth_imp_36(id self, SEL sel, id arg_2, id arg_3, SEL arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_36(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	SEL objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16@20 */
static id 
meth_imp_37(id self, SEL sel, id arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_37(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16@20@24 */
static id 
meth_imp_38(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_38(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16@20@24@28 */
static id 
meth_imp_39(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_39(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16@20@24@28@32 */
static id 
meth_imp_40(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5, id arg_6, id arg_7)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(7);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_40(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	id objc_arg7;
	struct objc_super super;

	if (PyTuple_Size(args) != 6) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @0@4:8@12@16@20@24^@28
// Skipped complex signature: @0@4:8@12@16@20@24^@28c32
/* signature: @0@4:8@12@16@20@24c28 */
static id 
meth_imp_41(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5, char arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_41(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	char objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16@20@24c28i32 */
static id 
meth_imp_42(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5, char arg_6, int arg_7)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(7);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_42(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	char objc_arg6;
	int objc_arg7;
	struct objc_super super;

	if (PyTuple_Size(args) != 6) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16@20@24i28 */
static id 
meth_imp_43(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5, int arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_43(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	int objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @0@4:8@12@16@20^@24
// Skipped complex signature: @0@4:8@12@16@20^{_NSZone=}24
/* signature: @0@4:8@12@16@20c24 */
static id 
meth_imp_44(id self, SEL sel, id arg_2, id arg_3, id arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_44(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16@20c24@28 */
static id 
meth_imp_45(id self, SEL sel, id arg_2, id arg_3, id arg_4, char arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_45(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	char objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16@20i24 */
static id 
meth_imp_46(id self, SEL sel, id arg_2, id arg_3, id arg_4, int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_46(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16@20i24@28 */
static id 
meth_imp_47(id self, SEL sel, id arg_2, id arg_3, id arg_4, int arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_47(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	int objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16@20{_NSPoint=ff}24 */
struct _NSPoint {
	float field_0;
	float field_1;
};

static id 
meth_imp_48(id self, SEL sel, id arg_2, id arg_3, id arg_4, struct _NSPoint arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_48(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct _NSPoint objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16I20 */
static id 
meth_imp_49(id self, SEL sel, id arg_2, id arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_49(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16I20@24 */
static id 
meth_imp_50(id self, SEL sel, id arg_2, id arg_3, unsigned int arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_50(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	unsigned int objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16I20@24@28 */
static id 
meth_imp_51(id self, SEL sel, id arg_2, id arg_3, unsigned int arg_4, id arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_51(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	unsigned int objc_arg4;
	id objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16S20 */
static id 
meth_imp_52(id self, SEL sel, id arg_2, id arg_3, unsigned short arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_52(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	unsigned short objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @0@4:8@12@16^@20
// Skipped complex signature: @0@4:8@12@16^{_NSPoint=ff}20
// Skipped complex signature: @0@4:8@12@16^{_NSZone=}20
/* signature: @0@4:8@12@16c20 */
static id 
meth_imp_53(id self, SEL sel, id arg_2, id arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_53(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16c20@24 */
static id 
meth_imp_54(id self, SEL sel, id arg_2, id arg_3, char arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_54(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	char objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16f40 */
static id 
meth_imp_55(id self, SEL sel, id arg_2, id arg_3, float arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_55(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	float objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16i20 */
static id 
meth_imp_56(id self, SEL sel, id arg_2, id arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_56(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16i20c24 */
static id 
meth_imp_57(id self, SEL sel, id arg_2, id arg_3, int arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_57(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	int objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12@16i20i24 */
static id 
meth_imp_58(id self, SEL sel, id arg_2, id arg_3, int arg_4, int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_58(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	int objc_arg4;
	int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @0@4:8@12@16i20i24^{_SelectionAnchor=iii}28c32
/* signature: @0@4:8@12@16o^@20 */
static id 
meth_imp_59(id self, SEL sel, id arg_2, id arg_3, id  *arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 2) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("@", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("@", v, arg_4);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_59(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(2);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("@", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("@", &objc_arg4);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		return result_list;
	}
}


/* signature: @0@4:8@12@16{_NSRange=II}20@28 */
static id 
meth_imp_60(id self, SEL sel, id arg_2, id arg_3, struct _NSRange arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_60(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct _NSRange objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12I16 */
static id 
meth_imp_61(id self, SEL sel, id arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_61(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12I16@20 */
static id 
meth_imp_62(id self, SEL sel, id arg_2, unsigned int arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_62(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	unsigned int objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12I16@20@24 */
static id 
meth_imp_63(id self, SEL sel, id arg_2, unsigned int arg_3, id arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_63(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	unsigned int objc_arg3;
	id objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12I16I20 */
static id 
meth_imp_64(id self, SEL sel, id arg_2, unsigned int arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_64(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	unsigned int objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @0@4:8@12I16^{_NSRange=II}20
// Skipped complex signature: @0@4:8@12I16^{_NSRange=II}20{_NSRange=II}24
/* signature: @0@4:8@12I16i20 */
static id 
meth_imp_65(id self, SEL sel, id arg_2, unsigned int arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_65(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	unsigned int objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12I16i20f40 */
static id 
meth_imp_66(id self, SEL sel, id arg_2, unsigned int arg_3, int arg_4, float arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_66(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	unsigned int objc_arg3;
	int objc_arg4;
	float objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12I16o^{_NSRange=II}20 */
static id 
meth_imp_67(id self, SEL sel, id arg_2, unsigned int arg_3, struct _NSRange  *arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 2) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("@", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("{_NSRange=II}", v, arg_4);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_67(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	unsigned int objc_arg3;
	struct _NSRange objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(2);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("@", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("{_NSRange=II}", &objc_arg4);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		return result_list;
	}
}


/* signature: @0@4:8@12I16o^{_NSRange=II}20{_NSRange=II}24 */
static id 
meth_imp_68(id self, SEL sel, id arg_2, unsigned int arg_3, struct _NSRange  *arg_4, struct _NSRange arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 2) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("@", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("{_NSRange=II}", v, arg_4);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_68(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	unsigned int objc_arg3;
	struct _NSRange objc_arg4;
	struct _NSRange objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(2);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("@", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("{_NSRange=II}", &objc_arg4);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		return result_list;
	}
}


/* signature: @0@4:8@12L16 */
static id 
meth_imp_69(id self, SEL sel, id arg_2, unsigned long arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("L", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_69(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	unsigned long objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("L", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @0@4:8@12^@16
// Skipped complex signature: @0@4:8@12^@16^{_NSZone=}20
// Skipped complex signature: @0@4:8@12^I16I20c24
// Skipped complex signature: @0@4:8@12^I16c20
// Skipped complex signature: @0@4:8@12^{?=^SI^SI^SI}16
// Skipped complex signature: @0@4:8@12^{?=^SI^SI^SI}16c20
// Skipped complex signature: @0@4:8@12^{OpaquePMPageFormat=}16^{OpaquePMPrintSettings=}20
// Skipped complex signature: @0@4:8@12^{OpaquePMPrinter=}16
// Skipped complex signature: @0@4:8@12^{_NSZone=}16
// Skipped complex signature: @0@4:8@12^{__CFURL=}16
// Skipped complex signature: @0@4:8@12^{tiff=*^{_NXStream}sccsll{?=IIIIIISSSSSSSSSSIIIffSSffII[2S]ISSSSI^S^S^S^S[3^S]*********[2I]II^I^I[2S]^f[2S]S^f^f^f[4^S]S[2S]**I^v}{?=SSL}^i^i[10i]liillil^?^?^?^?^?^?^?^?^?^?^?^?*ii*l*llii}16s20
/* signature: @0@4:8@12c16 */
static id 
meth_imp_70(id self, SEL sel, id arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_70(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12c16c20 */
static id 
meth_imp_71(id self, SEL sel, id arg_2, char arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_71(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	char objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12f40 */
static id 
meth_imp_72(id self, SEL sel, id arg_2, float arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_72(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	float objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12f40@20{_NSPoint=ff}24 */
static id 
meth_imp_73(id self, SEL sel, id arg_2, float arg_3, id arg_4, struct _NSPoint arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_73(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	float objc_arg3;
	id objc_arg4;
	struct _NSPoint objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12f40r^f20 */
static id 
meth_imp_74(id self, SEL sel, id arg_2, float arg_3, float  *arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_74(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	float objc_arg3;
	float objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12f40r^f20I24 */
static id 
meth_imp_75(id self, SEL sel, id arg_2, float arg_3, float  *arg_4, unsigned int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_75(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	float objc_arg3;
	float objc_arg4;
	unsigned int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12f40r^f20i24 */
static id 
meth_imp_76(id self, SEL sel, id arg_2, float arg_3, float  *arg_4, int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_76(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	float objc_arg3;
	float objc_arg4;
	int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12i16 */
static id 
meth_imp_77(id self, SEL sel, id arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_77(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12i16:20 */
static id 
meth_imp_78(id self, SEL sel, id arg_2, int arg_3, SEL arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_78(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	int objc_arg3;
	SEL objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12i16@20 */
static id 
meth_imp_79(id self, SEL sel, id arg_2, int arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_79(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	int objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12i16I20 */
static id 
meth_imp_80(id self, SEL sel, id arg_2, int arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_80(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	int objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @0@4:8@12i16^@20
// Skipped complex signature: @0@4:8@12i16^i20^@24
/* signature: @0@4:8@12i16f40 */
static id 
meth_imp_81(id self, SEL sel, id arg_2, int arg_3, float arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_81(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	int objc_arg3;
	float objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12i16i20 */
static id 
meth_imp_82(id self, SEL sel, id arg_2, int arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_82(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	int objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12i16i20@24 */
static id 
meth_imp_83(id self, SEL sel, id arg_2, int arg_3, int arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_83(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	int objc_arg3;
	int objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @0@4:8@12i16{_NSPoint=ff}20^v28
/* signature: @0@4:8@12i16{_NSRect={_NSPoint=ff}{_NSSize=ff}}20 */
struct _NSSize {
	float field_0;
	float field_1;
};
struct _NSRect {
	struct _NSPoint field_0;
	struct _NSSize field_1;
};

static id 
meth_imp_84(id self, SEL sel, id arg_2, int arg_3, struct _NSRect arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_84(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	int objc_arg3;
	struct _NSRect objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12o^@16 */
static id 
meth_imp_85(id self, SEL sel, id arg_2, id  *arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 2) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("@", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("@", v, arg_3);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_85(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(2);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("@", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("@", &objc_arg3);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		return result_list;
	}
}


/* signature: @0@4:8@12r*16I20 */
static id 
meth_imp_86(id self, SEL sel, id arg_2, char* arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_86(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	char* objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12r^f16 */
static id 
meth_imp_87(id self, SEL sel, id arg_2, float  *arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_87(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	float objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12r^{FSRef=[80C]}16 */
struct FSRef {
	unsigned char field_0[80];
};

static id 
meth_imp_88(id self, SEL sel, id arg_2, struct FSRef  *arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{FSRef=[80C]}", arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_88(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	struct FSRef objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{FSRef=[80C]}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12{_NSPoint=ff}16 */
static id 
meth_imp_89(id self, SEL sel, id arg_2, struct _NSPoint arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_89(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	struct _NSPoint objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12{_NSRange=II}16 */
static id 
meth_imp_90(id self, SEL sel, id arg_2, struct _NSRange arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_90(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	struct _NSRange objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12{_NSRange=II}16i24 */
static id 
meth_imp_91(id self, SEL sel, id arg_2, struct _NSRange arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_91(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	struct _NSRange objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16 */
static id 
meth_imp_92(id self, SEL sel, id arg_2, struct _NSRect arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_92(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	struct _NSRect objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32 */
static id 
meth_imp_93(id self, SEL sel, id arg_2, struct _NSRect arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_93(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	struct _NSRect objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8C12 */
static id 
meth_imp_94(id self, SEL sel, unsigned char arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("C", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_94(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned char objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("C", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8I12 */
static id 
meth_imp_95(id self, SEL sel, unsigned int arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_95(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8I12:16 */
static id 
meth_imp_96(id self, SEL sel, unsigned int arg_2, SEL arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_96(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned int objc_arg2;
	SEL objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8I12@16 */
static id 
meth_imp_97(id self, SEL sel, unsigned int arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_97(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned int objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8I12@16@20 */
static id 
meth_imp_98(id self, SEL sel, unsigned int arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_98(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned int objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @0@4:8I12@16@20^{_NSZone=}24
/* signature: @0@4:8I12@16@20c24 */
static id 
meth_imp_99(id self, SEL sel, unsigned int arg_2, id arg_3, id arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_99(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned int objc_arg2;
	id objc_arg3;
	id objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8I12@16@20l24 */
static id 
meth_imp_100(id self, SEL sel, unsigned int arg_2, id arg_3, id arg_4, long arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("l", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_100(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned int objc_arg2;
	id objc_arg3;
	id objc_arg4;
	long objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("l", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8I12@16I20 */
static id 
meth_imp_101(id self, SEL sel, unsigned int arg_2, id arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_101(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned int objc_arg2;
	id objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8I12I16 */
static id 
meth_imp_102(id self, SEL sel, unsigned int arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_102(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned int objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8I12I16@20s24i28 */
static id 
meth_imp_103(id self, SEL sel, unsigned int arg_2, unsigned int arg_3, id arg_4, short arg_5, int arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("s", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_103(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned int objc_arg2;
	unsigned int objc_arg3;
	id objc_arg4;
	short objc_arg5;
	int objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("s", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @0@4:8I12^I16
// Skipped complex signature: @0@4:8I12^{_NSRange=II}16
// Skipped complex signature: @0@4:8I12^{_NSRange=II}16^I20
// Skipped complex signature: @0@4:8I12^{_NSRange=II}16{_NSRange=II}20
/* signature: @0@4:8I12c16 */
static id 
meth_imp_104(id self, SEL sel, unsigned int arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_104(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned int objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8I12i16@20 */
static id 
meth_imp_105(id self, SEL sel, unsigned int arg_2, int arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_105(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned int objc_arg2;
	int objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8I12o^{_NSRange=II}16 */
static id 
meth_imp_106(id self, SEL sel, unsigned int arg_2, struct _NSRange  *arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 2) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("@", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("{_NSRange=II}", v, arg_3);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_106(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned int objc_arg2;
	struct _NSRange objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(2);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("@", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("{_NSRange=II}", &objc_arg3);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		return result_list;
	}
}


/* signature: @0@4:8I12o^{_NSRange=II}16{_NSRange=II}20 */
static id 
meth_imp_107(id self, SEL sel, unsigned int arg_2, struct _NSRange  *arg_3, struct _NSRange arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 2) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("@", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("{_NSRange=II}", v, arg_3);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_107(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned int objc_arg2;
	struct _NSRange objc_arg3;
	struct _NSRange objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(2);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("@", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("{_NSRange=II}", &objc_arg3);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		return result_list;
	}
}


// Skipped complex signature: @0@4:8I12r^v16I20
/* signature: @0@4:8I12{_NSPoint=ff}16@24 */
static id 
meth_imp_108(id self, SEL sel, unsigned int arg_2, struct _NSPoint arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_108(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned int objc_arg2;
	struct _NSPoint objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8I12{_NSRange=II}16 */
static id 
meth_imp_109(id self, SEL sel, unsigned int arg_2, struct _NSRange arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_109(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned int objc_arg2;
	struct _NSRange objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8L12 */
static id 
meth_imp_110(id self, SEL sel, unsigned long arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("L", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_110(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned long objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("L", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8L12L16 */
static id 
meth_imp_111(id self, SEL sel, unsigned long arg_2, unsigned long arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("L", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("L", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_111(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned long objc_arg2;
	unsigned long objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("L", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("L", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8Q12 */
static id 
meth_imp_112(id self, SEL sel, unsigned long long arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("Q", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_112(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned long long objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("Q", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8Q12s20c24 */
static id 
meth_imp_113(id self, SEL sel, unsigned long long arg_2, short arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("Q", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("s", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_113(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned long long objc_arg2;
	short objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("Q", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("s", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8S12 */
static id 
meth_imp_114(id self, SEL sel, unsigned short arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_114(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned short objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8S12@16 */
static id 
meth_imp_115(id self, SEL sel, unsigned short arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_115(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned short objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8S12I16@20 */
static id 
meth_imp_116(id self, SEL sel, unsigned short arg_2, unsigned int arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_116(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned short objc_arg2;
	unsigned int objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8S12S16 */
static id 
meth_imp_117(id self, SEL sel, unsigned short arg_2, unsigned short arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_117(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned short objc_arg2;
	unsigned short objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8S12S16@20 */
static id 
meth_imp_118(id self, SEL sel, unsigned short arg_2, unsigned short arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_118(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned short objc_arg2;
	unsigned short objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8S12i16 */
static id 
meth_imp_119(id self, SEL sel, unsigned short arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_119(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned short objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @0@4:8^?12^?16:20
// Skipped complex signature: @0@4:8^?12^v16
// Skipped complex signature: @0@4:8^?12^v16@20
// Skipped complex signature: @0@4:8^?12i16
// Skipped complex signature: @0@4:8^@12
// Skipped complex signature: @0@4:8^@12@16
// Skipped complex signature: @0@4:8^@12I16
// Skipped complex signature: @0@4:8^@12I16@20c24c28
// Skipped complex signature: @0@4:8^@12^@16I20
// Skipped complex signature: @0@4:8^@12c16
// Skipped complex signature: @0@4:8^@12c16c20
// Skipped complex signature: @0@4:8^S12I16
// Skipped complex signature: @0@4:8^S12I16c20
// Skipped complex signature: @0@4:8^c12
// Skipped complex signature: @0@4:8^i12
// Skipped complex signature: @0@4:8^i12^i16
// Skipped complex signature: @0@4:8^v12
// Skipped complex signature: @0@4:8^v12I16
// Skipped complex signature: @0@4:8^v12I16c20
// Skipped complex signature: @0@4:8^v12I16c20c24c28
// Skipped complex signature: @0@4:8^v12c16
// Skipped complex signature: @0@4:8^v12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16
// Skipped complex signature: @0@4:8^{?=*i}12^*16^*20f40
// Skipped complex signature: @0@4:8^{CPSProcessSerNum=II}12c16c20
// Skipped complex signature: @0@4:8^{FSCatalogInfo=SsIICCCC{UTCDateTime=SIS}{UTCDateTime=SIS}{UTCDateTime=SIS}{UTCDateTime=SIS}{UTCDateTime=SIS}[4I][16C][16C]QQQQII}12@16^{FSRef=[80C]}20^{FSRef=[80C]}24^{HFSUniStr255=S[255S]}28c32
// Skipped complex signature: @0@4:8^{FSRef=[80C]}12
// Skipped complex signature: @0@4:8^{FSRef=[80C]}12c16c20
// Skipped complex signature: @0@4:8^{FSRef=[80C]}12i16
// Skipped complex signature: @0@4:8^{NSCharSetPrivateStruct=i[4i]iiii[1i]}12
// Skipped complex signature: @0@4:8^{OpaqueWindowPtr=}12c16
// Skipped complex signature: @0@4:8^{OpaqueWindowPtr=}12c16c20
// Skipped complex signature: @0@4:8^{_NSPoint=ff}12
// Skipped complex signature: @0@4:8^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12
// Skipped complex signature: @0@4:8^{_NSRefCountedRunArray=IIIIII[0{_NSRunArrayItem=I@}]}12
// Skipped complex signature: @0@4:8^{_NSRulebookSetHeader=i[4L]iiii[1i]}12
// Skipped complex signature: @0@4:8^{_NSStringBuffer=II@II[32S]S}12
// Skipped complex signature: @0@4:8^{_NSZone=}12
// Skipped complex signature: @0@4:8^{_ProtocolTemplate=#*^{objc_protocol_list}^{objc_method_description_list}^{objc_method_description_list}}12i16
// Skipped complex signature: @0@4:8^{_SelectionAnchor=iii}12^{_SelectionAnchor=iii}16c20c24
// Skipped complex signature: @0@4:8^{_SelectionAnchor=iii}12c16
// Skipped complex signature: @0@4:8^{__ABVCard={__ABType=^{__ABTypeClass}SS}^{__CFAllocator}^{__CFArray}^{__CFDate}CCS}12
// Skipped complex signature: @0@4:8^{__CFNetService=}12
// Skipped complex signature: @0@4:8^{__CFNotificationCenter=}12
// Skipped complex signature: @0@4:8^{__CFPasteboard=}12
// Skipped complex signature: @0@4:8^{__CFReadStream=}12@16^{__CFDictionary=}20
// Skipped complex signature: @0@4:8^{__CFSocket=}12i16i20i24
// Skipped complex signature: @0@4:8^{_object=i^{_typeobject}}12
// Skipped complex signature: @0@4:8^{stat=iISSIIi{timespec=il}{timespec=il}{timespec=il}qqIIIi[2q]}12
/* signature: @0@4:8c12 */
static id 
meth_imp_120(id self, SEL sel, char arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_120(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	char objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8c12@16 */
static id 
meth_imp_121(id self, SEL sel, char arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_121(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	char objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @0@4:8c12I16r^v20
/* signature: @0@4:8c12c16 */
static id 
meth_imp_122(id self, SEL sel, char arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_122(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	char objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8c12i16 */
static id 
meth_imp_123(id self, SEL sel, char arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_123(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	char objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8c12i16i20c24 */
static id 
meth_imp_124(id self, SEL sel, char arg_2, int arg_3, int arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_124(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	char objc_arg2;
	int objc_arg3;
	int objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8d40 */
static id 
meth_imp_125(id self, SEL sel, double arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_125(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	double objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8d40@20 */
static id 
meth_imp_126(id self, SEL sel, double arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_126(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	double objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8d40@20:24@28c32 */
static id 
meth_imp_127(id self, SEL sel, double arg_2, id arg_3, SEL arg_4, id arg_5, char arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_127(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	double objc_arg2;
	id objc_arg3;
	SEL objc_arg4;
	id objc_arg5;
	char objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8d40@20c24 */
static id 
meth_imp_128(id self, SEL sel, double arg_2, id arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_128(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	double objc_arg2;
	id objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8f40 */
static id 
meth_imp_129(id self, SEL sel, float arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_129(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	float objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8f40@16 */
static id 
meth_imp_130(id self, SEL sel, float arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_130(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	float objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8f40f48 */
static id 
meth_imp_131(id self, SEL sel, float arg_2, float arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_131(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	float objc_arg2;
	float objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8f40f48c20 */
static id 
meth_imp_132(id self, SEL sel, float arg_2, float arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_132(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	float objc_arg2;
	float objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8f40f48f56f64 */
static id 
meth_imp_133(id self, SEL sel, float arg_2, float arg_3, float arg_4, float arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_133(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	float objc_arg2;
	float objc_arg3;
	float objc_arg4;
	float objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8f40f48f56f64f72 */
static id 
meth_imp_134(id self, SEL sel, float arg_2, float arg_3, float arg_4, float arg_5, float arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_134(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	float objc_arg2;
	float objc_arg3;
	float objc_arg4;
	float objc_arg5;
	float objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12 */
static id 
meth_imp_135(id self, SEL sel, int arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_135(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12@16 */
static id 
meth_imp_136(id self, SEL sel, int arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_136(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12@16@20@24i28 */
static id 
meth_imp_137(id self, SEL sel, int arg_2, id arg_3, id arg_4, id arg_5, int arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_137(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	int objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @0@4:8i12@16^i20
/* signature: @0@4:8i12@16i20 */
static id 
meth_imp_138(id self, SEL sel, int arg_2, id arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_138(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	id objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12I16 */
static id 
meth_imp_139(id self, SEL sel, int arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_139(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12c16 */
static id 
meth_imp_140(id self, SEL sel, int arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_140(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12f40 */
static id 
meth_imp_141(id self, SEL sel, int arg_2, float arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_141(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	float objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12f40r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}20r^{_NSPoint=ff}24 */
static id 
meth_imp_142(id self, SEL sel, int arg_2, float arg_3, struct _NSRect  *arg_4, struct _NSPoint  *arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_142(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	float objc_arg3;
	struct _NSRect objc_arg4;
	struct _NSPoint objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12i16 */
static id 
meth_imp_143(id self, SEL sel, int arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_143(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12i16@20 */
static id 
meth_imp_144(id self, SEL sel, int arg_2, int arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_144(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	int objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12i16c20 */
static id 
meth_imp_145(id self, SEL sel, int arg_2, int arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_145(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	int objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12i16i20 */
static id 
meth_imp_146(id self, SEL sel, int arg_2, int arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_146(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	int objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12i16i20@24 */
static id 
meth_imp_147(id self, SEL sel, int arg_2, int arg_3, int arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_147(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	int objc_arg3;
	int objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12i16i20i24 */
static id 
meth_imp_148(id self, SEL sel, int arg_2, int arg_3, int arg_4, int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_148(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	int objc_arg3;
	int objc_arg4;
	int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12i16i20i24i28i32 */
static id 
meth_imp_149(id self, SEL sel, int arg_2, int arg_3, int arg_4, int arg_5, int arg_6, int arg_7)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(7);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_149(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	int objc_arg3;
	int objc_arg4;
	int objc_arg5;
	int objc_arg6;
	int objc_arg7;
	struct objc_super super;

	if (PyTuple_Size(args) != 6) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}16 */
static id 
meth_imp_150(id self, SEL sel, int arg_2, struct _NSRect  *arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_150(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	struct _NSRect objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}16I20 */
static id 
meth_imp_151(id self, SEL sel, int arg_2, struct _NSRect  *arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_151(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	struct _NSRect objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12s16c20c24c28c32 */
static id 
meth_imp_152(id self, SEL sel, int arg_2, short arg_3, char arg_4, char arg_5, char arg_6, char arg_7)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(7);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("s", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_152(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	short objc_arg3;
	char objc_arg4;
	char objc_arg5;
	char objc_arg6;
	char objc_arg7;
	struct objc_super super;

	if (PyTuple_Size(args) != 6) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("s", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12{_NSRange=II}16 */
static id 
meth_imp_153(id self, SEL sel, int arg_2, struct _NSRange arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_153(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	struct _NSRange objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8i12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16 */
static id 
meth_imp_154(id self, SEL sel, int arg_2, struct _NSRect arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_154(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	struct _NSRect objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8l12 */
static id 
meth_imp_155(id self, SEL sel, long arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("l", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_155(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	long objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("l", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8q12 */
static id 
meth_imp_156(id self, SEL sel, long long arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("q", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_156(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	long long objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("q", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8r*12 */
static id 
meth_imp_157(id self, SEL sel, char* arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_157(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	char* objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8r*12I16 */
static id 
meth_imp_158(id self, SEL sel, char* arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_158(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	char* objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8r*12I16I20 */
static id 
meth_imp_159(id self, SEL sel, char* arg_2, unsigned int arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_159(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	char* objc_arg2;
	unsigned int objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8r^S12I16 */
static id 
meth_imp_160(id self, SEL sel, unsigned short  *arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("S", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_160(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	unsigned short objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @0@4:8r^v12
// Skipped complex signature: @0@4:8r^v12I16
// Skipped complex signature: @0@4:8r^v12I16c20
// Skipped complex signature: @0@4:8r^v12r*16
/* signature: @0@4:8r^{AEDesc=I^^{OpaqueAEDataStorageType}}12 */
struct OpaqueAEDataStorageType;struct AEDesc {
	unsigned int field_0;
	struct OpaqueAEDataStorageType  * *field_1;
};

static id 
meth_imp_161(id self, SEL sel, struct AEDesc  *arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{AEDesc=I^^{OpaqueAEDataStorageType=}}", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_161(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct AEDesc objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{AEDesc=I^^{OpaqueAEDataStorageType=}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8r^{FSRef=[80C]}12 */
static id 
meth_imp_162(id self, SEL sel, struct FSRef  *arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{FSRef=[80C]}", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_162(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct FSRef objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{FSRef=[80C]}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12 */
static id 
meth_imp_163(id self, SEL sel, struct _NSRect  *arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_163(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12I16i20c24@28 */
static id 
meth_imp_164(id self, SEL sel, struct _NSRect  *arg_2, unsigned int arg_3, int arg_4, char arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_164(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	unsigned int objc_arg3;
	int objc_arg4;
	char objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12I16i20c24@28@32 */
static id 
meth_imp_165(id self, SEL sel, struct _NSRect  *arg_2, unsigned int arg_3, int arg_4, char arg_5, id arg_6, id arg_7)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(7);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_165(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	unsigned int objc_arg3;
	int objc_arg4;
	char objc_arg5;
	id objc_arg6;
	id objc_arg7;
	struct objc_super super;

	if (PyTuple_Size(args) != 6) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8r^{_NSSize=ff}12@16 */
static id 
meth_imp_166(id self, SEL sel, struct _NSSize  *arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_166(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSSize objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8s12 */
static id 
meth_imp_167(id self, SEL sel, short arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("s", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_167(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	short objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("s", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8s12@16 */
static id 
meth_imp_168(id self, SEL sel, short arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("s", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_168(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	short objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("s", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{CGPoint=ff}12 */
struct CGPoint {
	float field_0;
	float field_1;
};

static id 
meth_imp_169(id self, SEL sel, struct CGPoint arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{CGPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_169(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct CGPoint objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{CGPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{NSButtonState=iccc}12 */
struct NSButtonState {
	int field_0;
	char field_1;
	char field_2;
	char field_3;
};

static id 
meth_imp_170(id self, SEL sel, struct NSButtonState arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{NSButtonState=iccc}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_170(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct NSButtonState objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{NSButtonState=iccc}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSPoint=ff}12 */
static id 
meth_imp_171(id self, SEL sel, struct _NSPoint arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_171(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSPoint objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSPoint=ff}12c20 */
static id 
meth_imp_172(id self, SEL sel, struct _NSPoint arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_172(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSPoint objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSRange=II}12 */
static id 
meth_imp_173(id self, SEL sel, struct _NSRange arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_173(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRange objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSRange=II}12@20 */
static id 
meth_imp_174(id self, SEL sel, struct _NSRange arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_174(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRange objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSRange=II}12@20@24 */
static id 
meth_imp_175(id self, SEL sel, struct _NSRange arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_175(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRange objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSRange=II}12@20@24{_NSRange=II}28 */
static id 
meth_imp_176(id self, SEL sel, struct _NSRange arg_2, id arg_3, id arg_4, struct _NSRange arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_176(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRange objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct _NSRange objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @0@4:8{_NSRange=II}12^{_NSZone=}20
/* signature: @0@4:8{_NSRange=II}12c20 */
static id 
meth_imp_177(id self, SEL sel, struct _NSRange arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_177(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRange objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12 */
static id 
meth_imp_178(id self, SEL sel, struct _NSRect arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_178(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28 */
static id 
meth_imp_179(id self, SEL sel, struct _NSRect arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_179(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28@32 */
static id 
meth_imp_180(id self, SEL sel, struct _NSRect arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_180(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28i32 */
static id 
meth_imp_181(id self, SEL sel, struct _NSRect arg_2, id arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_181(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	id objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12I28@32 */
static id 
meth_imp_182(id self, SEL sel, struct _NSRect arg_2, unsigned int arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_182(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	unsigned int objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12c28 */
static id 
meth_imp_183(id self, SEL sel, struct _NSRect arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_183(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12i28 */
static id 
meth_imp_184(id self, SEL sel, struct _NSRect arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_184(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12s28 */
static id 
meth_imp_185(id self, SEL sel, struct _NSRect arg_2, short arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("s", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_185(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	short objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("s", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSSize=ff}12 */
static id 
meth_imp_186(id self, SEL sel, struct _NSSize arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_186(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSSize objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSSize=ff}12@20 */
static id 
meth_imp_187(id self, SEL sel, struct _NSSize arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_187(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSSize objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSSize=ff}12i20 */
static id 
meth_imp_188(id self, SEL sel, struct _NSSize arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_188(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSSize objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSSize=ff}12i20c24c28 */
static id 
meth_imp_189(id self, SEL sel, struct _NSSize arg_2, int arg_3, char arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_189(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSSize objc_arg2;
	int objc_arg3;
	char objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @0@4:8{_NSSize=ff}12i20c24c28c32 */
static id 
meth_imp_190(id self, SEL sel, struct _NSSize arg_2, int arg_3, char arg_4, char arg_5, char arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_190(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSSize objc_arg2;
	int objc_arg3;
	char objc_arg4;
	char objc_arg5;
	char objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @36@4:8@12:16@20@24@28@32I32 */
static id 
meth_imp_191(id self, SEL sel, id arg_2, SEL arg_3, id arg_4, id arg_5, id arg_6, id arg_7, unsigned int arg_8)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(8);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_191(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	SEL objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	id objc_arg7;
	unsigned int objc_arg8;
	struct objc_super super;

	if (PyTuple_Size(args) != 7) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @36@4:8@12@16c20@24@28:32I32 */
static id 
meth_imp_192(id self, SEL sel, id arg_2, id arg_3, char arg_4, id arg_5, id arg_6, SEL arg_7, unsigned int arg_8)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(8);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_192(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	char objc_arg4;
	id objc_arg5;
	id objc_arg6;
	SEL objc_arg7;
	unsigned int objc_arg8;
	struct objc_super super;

	if (PyTuple_Size(args) != 7) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @36@4:8@12d40@24:28@32c35 */
static id 
meth_imp_193(id self, SEL sel, id arg_2, double arg_3, id arg_4, SEL arg_5, id arg_6, char arg_7)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(7);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_193(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	double objc_arg3;
	id objc_arg4;
	SEL objc_arg5;
	id objc_arg6;
	char objc_arg7;
	struct objc_super super;

	if (PyTuple_Size(args) != 6) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @36@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32@32 */
static id 
meth_imp_194(id self, SEL sel, id arg_2, struct _NSRect arg_3, id arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_194(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	struct _NSRect objc_arg3;
	id objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @36@4:8@12{_NSSize=ff}16f40f48{_NSPoint=ff}28 */
static id 
meth_imp_195(id self, SEL sel, id arg_2, struct _NSSize arg_3, float arg_4, float arg_5, struct _NSPoint arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_195(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	struct _NSSize objc_arg3;
	float objc_arg4;
	float objc_arg5;
	struct _NSPoint objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @36@4:8i12@16@20@24@28@32*32 */
static id 
meth_imp_196(id self, SEL sel, int arg_2, id arg_3, id arg_4, id arg_5, id arg_6, id arg_7, char* arg_8)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(8);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_196(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	id objc_arg7;
	char* objc_arg8;
	struct objc_super super;

	if (PyTuple_Size(args) != 7) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @36@4:8i12I16I20I24I28I32@32 */
static id 
meth_imp_197(id self, SEL sel, int arg_2, unsigned int arg_3, unsigned int arg_4, unsigned int arg_5, unsigned int arg_6, unsigned int arg_7, id arg_8)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(8);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_197(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	unsigned int objc_arg3;
	unsigned int objc_arg4;
	unsigned int objc_arg5;
	unsigned int objc_arg6;
	unsigned int objc_arg7;
	id objc_arg8;
	struct objc_super super;

	if (PyTuple_Size(args) != 7) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @36@4:8r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@16@20@24@28i32i32 */
static id 
meth_imp_198(id self, SEL sel, struct _NSRect  *arg_2, id arg_3, id arg_4, id arg_5, id arg_6, int arg_7, int arg_8)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(8);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_198(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	int objc_arg7;
	int objc_arg8;
	struct objc_super super;

	if (PyTuple_Size(args) != 7) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28I32@32 */
static id 
meth_imp_199(id self, SEL sel, struct _NSRect arg_2, id arg_3, unsigned int arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_199(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	id objc_arg3;
	unsigned int objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12I28i32c35 */
static id 
meth_imp_200(id self, SEL sel, struct _NSRect arg_2, unsigned int arg_3, int arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_200(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	unsigned int objc_arg3;
	int objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @40@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12I28i32c35@36 */
static id 
meth_imp_201(id self, SEL sel, struct _NSRect arg_2, unsigned int arg_3, int arg_4, char arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_201(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	unsigned int objc_arg3;
	int objc_arg4;
	char objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @40@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12i28#32i32i36 */
static id 
meth_imp_202(id self, SEL sel, struct _NSRect arg_2, int arg_3, Class arg_4, int arg_5, int arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("#", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_202(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	int objc_arg3;
	Class objc_arg4;
	int objc_arg5;
	int objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("#", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @40@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12i28@32i32i36 */
static id 
meth_imp_203(id self, SEL sel, struct _NSRect arg_2, int arg_3, id arg_4, int arg_5, int arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_203(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct _NSRect objc_arg2;
	int objc_arg3;
	id objc_arg4;
	int objc_arg5;
	int objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @48@4:8^*12i16i20i24i28c32c35@36i40i44
/* signature: @48@4:8i12{_NSPoint=ff}16I24d40i32@36i40i44f48 */
static id 
meth_imp_204(id self, SEL sel, int arg_2, struct _NSPoint arg_3, unsigned int arg_4, double arg_5, int arg_6, id arg_7, int arg_8, int arg_9, float arg_10)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(10);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_9);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 8, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_10);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 9, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_204(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	struct _NSPoint objc_arg3;
	unsigned int objc_arg4;
	double objc_arg5;
	int objc_arg6;
	id objc_arg7;
	int objc_arg8;
	int objc_arg9;
	float objc_arg10;
	struct objc_super super;

	if (PyTuple_Size(args) != 9) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 7);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg9);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 8);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg10);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8, objc_arg9, objc_arg10);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @52@4:8i12{_NSPoint=ff}16I24d40i32@36i40i44^v48
/* signature: @52@4:8i12{_NSPoint=ff}16I24d40i32@36s42i44i48 */
static id 
meth_imp_205(id self, SEL sel, int arg_2, struct _NSPoint arg_3, unsigned int arg_4, double arg_5, int arg_6, id arg_7, short arg_8, int arg_9, int arg_10)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(10);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("s", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_9);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 8, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_10);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 9, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_205(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	struct _NSPoint objc_arg3;
	unsigned int objc_arg4;
	double objc_arg5;
	int objc_arg6;
	id objc_arg7;
	short objc_arg8;
	int objc_arg9;
	int objc_arg10;
	struct objc_super super;

	if (PyTuple_Size(args) != 9) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("s", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 7);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg9);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 8);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg10);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8, objc_arg9, objc_arg10);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


// Skipped complex signature: @56@4:8^*12i16i20i24i28c32c35@36i40i44{_NSSize=ff}48
/* signature: @56@4:8i12{_NSPoint=ff}16I24d40i32@36@40@44c51S54 */
static id 
meth_imp_206(id self, SEL sel, int arg_2, struct _NSPoint arg_3, unsigned int arg_4, double arg_5, int arg_6, id arg_7, id arg_8, id arg_9, char arg_10, unsigned short arg_11)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(11);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_9);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 8, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_10);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 9, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_11);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 10, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_206(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	int objc_arg2;
	struct _NSPoint objc_arg3;
	unsigned int objc_arg4;
	double objc_arg5;
	int objc_arg6;
	id objc_arg7;
	id objc_arg8;
	id objc_arg9;
	char objc_arg10;
	unsigned short objc_arg11;
	struct objc_super super;

	if (PyTuple_Size(args) != 10) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 7);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg9);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 8);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg10);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 9);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg11);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8, objc_arg9, objc_arg10, objc_arg11);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @@: */
static id 
meth_imp_207(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_207(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @@:@ */
static id 
meth_imp_208(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_208(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @@:@@ */
static id 
meth_imp_209(id self, SEL sel, id arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_209(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @@:@@@ */
static id 
meth_imp_210(id self, SEL sel, id arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_210(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @@:@@@@ */
static id 
meth_imp_211(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_211(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @@:@@@@@ */
static id 
meth_imp_212(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_212(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @@:@@@@@@ */
static id 
meth_imp_213(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5, id arg_6, id arg_7)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(7);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_213(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	id objc_arg7;
	struct objc_super super;

	if (PyTuple_Size(args) != 6) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @@:@@@@@@@ */
static id 
meth_imp_214(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5, id arg_6, id arg_7, id arg_8)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(8);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_214(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	id objc_arg7;
	id objc_arg8;
	struct objc_super super;

	if (PyTuple_Size(args) != 7) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: @@:@@i */
static id 
meth_imp_215(id self, SEL sel, id arg_2, id arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_215(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: C0@4:8 */
static unsigned char 
meth_imp_216(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned char objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("C", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_216(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned char objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (unsigned char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("C", &objc_retval);
	return v;
}


// Skipped complex signature: C0@4:8I12^{OpaqueMenuRef=}16S20
/* signature: I0@4:8 */
static unsigned int 
meth_imp_217(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_217(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8:12 */
static unsigned int 
meth_imp_218(id self, SEL sel, SEL arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_218(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	SEL objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8:12@16 */
static unsigned int 
meth_imp_219(id self, SEL sel, SEL arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_219(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	SEL objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8@12 */
static unsigned int 
meth_imp_220(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_220(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8@12@16 */
static unsigned int 
meth_imp_221(id self, SEL sel, id arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_221(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8@12@16@20 */
static unsigned int 
meth_imp_222(id self, SEL sel, id arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_222(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8@12@16I20{_NSRange=II}24 */
static unsigned int 
meth_imp_223(id self, SEL sel, id arg_2, id arg_3, unsigned int arg_4, struct _NSRange arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_223(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	id objc_arg2;
	id objc_arg3;
	unsigned int objc_arg4;
	struct _NSRange objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8@12@16c20 */
static unsigned int 
meth_imp_224(id self, SEL sel, id arg_2, id arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_224(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	id objc_arg2;
	id objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8@12I16 */
static unsigned int 
meth_imp_225(id self, SEL sel, id arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_225(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	id objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8@12I16{_NSRange=II}20@28 */
static unsigned int 
meth_imp_226(id self, SEL sel, id arg_2, unsigned int arg_3, struct _NSRange arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_226(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	id objc_arg2;
	unsigned int objc_arg3;
	struct _NSRange objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8@12i16@20c24 */
static unsigned int 
meth_imp_227(id self, SEL sel, id arg_2, int arg_3, id arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_227(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	id objc_arg2;
	int objc_arg3;
	id objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8@12{_NSRange=II}16 */
static unsigned int 
meth_imp_228(id self, SEL sel, id arg_2, struct _NSRange arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_228(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	id objc_arg2;
	struct _NSRange objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8@12{_NSRange=II}16c24 */
static unsigned int 
meth_imp_229(id self, SEL sel, id arg_2, struct _NSRange arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_229(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	id objc_arg2;
	struct _NSRange objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8I12 */
static unsigned int 
meth_imp_230(id self, SEL sel, unsigned int arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_230(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	unsigned int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8I12*16 */
static unsigned int 
meth_imp_231(id self, SEL sel, unsigned int arg_2, char* arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_231(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	unsigned int objc_arg2;
	char* objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


// Skipped complex signature: I0@4:8I12^c16
/* signature: I0@4:8I12c16 */
static unsigned int 
meth_imp_232(id self, SEL sel, unsigned int arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_232(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	unsigned int objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8I12{_NSRange=II}16 */
static unsigned int 
meth_imp_233(id self, SEL sel, unsigned int arg_2, struct _NSRange arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_233(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	unsigned int objc_arg2;
	struct _NSRange objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


// Skipped complex signature: I0@4:8I12{_NSRange=II}16^c24^{ATSGlyphVector=III^v*I^v^{ATSStyleSetting}SsiiI{FixedRect=iiii}IiiiSS^S^s^s^i^i}28
/* signature: I0@4:8S12 */
static unsigned int 
meth_imp_234(id self, SEL sel, unsigned short arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_234(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	unsigned short objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


// Skipped complex signature: I0@4:8^I12
// Skipped complex signature: I0@4:8^I12@16
// Skipped complex signature: I0@4:8^I12@16I20
// Skipped complex signature: I0@4:8^I12{_NSRange=II}16
// Skipped complex signature: I0@4:8^i12
/* signature: I0@4:8c12 */
static unsigned int 
meth_imp_235(id self, SEL sel, char arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_235(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	char objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8i12 */
static unsigned int 
meth_imp_236(id self, SEL sel, int arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_236(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8l12 */
static unsigned int 
meth_imp_237(id self, SEL sel, long arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("l", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_237(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	long objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("l", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


// Skipped complex signature: I0@4:8r^v12I16
/* signature: I0@4:8{_NSPoint=ff}12 */
static unsigned int 
meth_imp_238(id self, SEL sel, struct _NSPoint arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_238(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	struct _NSPoint objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


/* signature: I0@4:8{_NSPoint=ff}12@20 */
static unsigned int 
meth_imp_239(id self, SEL sel, struct _NSPoint arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_239(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	struct _NSPoint objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("I", &objc_retval);
	return v;
}


// Skipped complex signature: I0@4:8{_NSPoint=ff}12@20^f24
// Skipped complex signature: I0@4:8{_NSRange=II}12^I20^I24^i28^c32
// Skipped complex signature: I36@4:8{_NSRange=II}12^I20^I24^i28^c32*32
/* signature: Io^@co^@@ */
static unsigned int 
meth_imp_240(id self, SEL sel, id  *arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 2) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("I", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("@", v, arg_2);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_240(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(3);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("I", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("@", &objc_arg2);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		return result_list;
	}
}


/* signature: L0@4:8 */
static unsigned long 
meth_imp_241(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned long objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("L", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_241(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned long objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (unsigned long)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("L", &objc_retval);
	return v;
}


/* signature: L0@4:8@12 */
static unsigned long 
meth_imp_242(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned long objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("L", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_242(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned long objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned long)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("L", &objc_retval);
	return v;
}


/* signature: O@0@4:8nO@12 */
static id 
meth_imp_243(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_243(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: O@0@4:8nO@12nO@16 */
static id 
meth_imp_244(id self, SEL sel, id arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	id objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("@", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_244(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (id)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("@", &objc_retval);
	return v;
}


/* signature: Q0@4:8 */
static unsigned long long 
meth_imp_245(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned long long objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("Q", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_245(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned long long objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (unsigned long long)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("Q", &objc_retval);
	return v;
}


/* signature: S0@4:8 */
static unsigned short 
meth_imp_246(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned short objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("S", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_246(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned short objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (unsigned short)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("S", &objc_retval);
	return v;
}


/* signature: S0@4:8I12 */
static unsigned short 
meth_imp_247(id self, SEL sel, unsigned int arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned short objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("S", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_247(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned short objc_retval;
	unsigned int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (unsigned short)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("S", &objc_retval);
	return v;
}


/* signature: Vv0@4:8 */
static void 
meth_imp_248(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_248(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: Vv0@4:8@12 */
static void 
meth_imp_249(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_249(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: Vv0@4:8@12i16 */
static void 
meth_imp_250(id self, SEL sel, id arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_250(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: Vv0@4:8i12c16 */
static void 
meth_imp_251(id self, SEL sel, int arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_251(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: Vv0@4:8nO@12nO@16 */
static void 
meth_imp_252(id self, SEL sel, id arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_252(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: Vv0@4:8nO@12ni16 */
static void 
meth_imp_253(id self, SEL sel, id arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_253(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: ^*0@4:8
// Skipped complex signature: ^?0@4:8:12
// Skipped complex signature: ^@0@4:8
// Skipped complex signature: ^S0@4:8
// Skipped complex signature: ^i0@4:8
// Skipped complex signature: ^i0@4:8@12^i16
// Skipped complex signature: ^i0@4:8S12
// Skipped complex signature: ^v0@4:8
// Skipped complex signature: ^v0@4:8@12
// Skipped complex signature: ^v0@4:8I12
// Skipped complex signature: ^v0@4:8I12^{_NSRange=II}16
// Skipped complex signature: ^v0@4:8^I12
// Skipped complex signature: ^v0@4:8c12
// Skipped complex signature: ^v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12
// Skipped complex signature: ^v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12c28
// Skipped complex signature: ^{CGPDFDocument=}0@4:8
// Skipped complex signature: ^{FSRef=[80C]}0@4:8
// Skipped complex signature: ^{OpaqueCoreDragHandler=}0@4:8
// Skipped complex signature: ^{OpaqueGrafPtr=}0@4:8
// Skipped complex signature: ^{OpaqueIconRef=}0@4:8
// Skipped complex signature: ^{OpaquePMPageFormat=}0@4:8@12
// Skipped complex signature: ^{OpaquePMPrintSettings=}0@4:8@12
// Skipped complex signature: ^{OpaqueWindowPtr=}0@4:8
// Skipped complex signature: ^{_CoercerData=@:}0@4:8#12#16
// Skipped complex signature: ^{_NSMapTable=}0@4:8c12
// Skipped complex signature: ^{_NSModalSession=@@^{_NSModalSession}iciI^vi@@:^vi}0@4:8@12
// Skipped complex signature: ^{_NSModalSession=@@^{_NSModalSession}iciI^vi@@:^vi}0@4:8@12@16
// Skipped complex signature: ^{_NSModalSession=@@^{_NSModalSession}iciI^vi@@:^vi}0@4:8@12@16@20:24^v28
// Skipped complex signature: ^{_NSRect={_NSPoint=ff}{_NSSize=ff}}0@4:8{_NSRange=II}12{_NSRange=II}20@28^I32
// Skipped complex signature: ^{_NSRect={_NSPoint=ff}{_NSSize=ff}}0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12
// Skipped complex signature: ^{_NSRect={_NSPoint=ff}{_NSSize=ff}}36@4:8{_NSRange=II}12{_NSRange=II}20@28^I32c35
// Skipped complex signature: ^{_NSRulebookSetHeader=i[4L]iiii[1i]}0@4:8
// Skipped complex signature: ^{_NSRulebookSetHeader=i[4L]iiii[1i]}0@4:8I12
// Skipped complex signature: ^{_NSRulebookTestStruct=iii[12i]}0@4:8I12
// Skipped complex signature: ^{_NSZone=}0@4:8
// Skipped complex signature: ^{_NXStream=I**iilii^{stream_functions}^v}0@4:8
// Skipped complex signature: ^{_PrivatePrintOperationInfo={_NSRect={_NSPoint=ff}{_NSSize=ff}}{_NSRect={_NSPoint=ff}{_NSSize=ff}}cccccccciiiiiii@@{_NSRect={_NSPoint=ff}{_NSSize=ff}}ccciffffii{_NSPoint=ff}I^{_NSModalSession}iiciii@c@ic@@i@}0@4:8
// Skipped complex signature: ^{__ABVCard={__ABType=^{__ABTypeClass}SS}^{__CFAllocator}^{__CFArray}^{__CFDate}CCS}0@4:8
// Skipped complex signature: ^{__CFArray=}0@4:8@12
// Skipped complex signature: ^{__CFArray=}0@4:8c12
// Skipped complex signature: ^{__CFArray=}0@4:8c12c16
// Skipped complex signature: ^{__CFBundle=}0@4:8
// Skipped complex signature: ^{__CFCharacterSet=}0@4:8
// Skipped complex signature: ^{__CFDate=}0@4:8
// Skipped complex signature: ^{__CFDictionary=}0@4:8@12
// Skipped complex signature: ^{__CFHTTPMessage=}0@4:8@12c16
// Skipped complex signature: ^{__CFNetService=}0@4:8
// Skipped complex signature: ^{__CFNotificationCenter=}0@4:8
// Skipped complex signature: ^{__CFPasteboard=}0@4:8
// Skipped complex signature: ^{__CFReadStream=}0@4:8
// Skipped complex signature: ^{__CFRunLoop=}0@4:8
// Skipped complex signature: ^{__CFSet=}0@4:8c12
// Skipped complex signature: ^{__CFSocket=}0@4:8@12
// Skipped complex signature: ^{__CFURL=}0@4:8
// Skipped complex signature: ^{__EventHandlerInfo=@:}0@4:8I12I16
// Skipped complex signature: ^{_object=i^{_typeobject}}0@4:8
// Skipped complex signature: ^{dataFileStruct=^{c4_Storage}**^{c4_View}}0@4:8
// Skipped complex signature: ^{objc_method_description=:*}0@4:8:12
/* signature: c0@4:8 */
static char 
meth_imp_254(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_254(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8#12 */
static char 
meth_imp_255(id self, SEL sel, Class arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("#", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_255(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	Class objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("#", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8#12@16 */
static char 
meth_imp_256(id self, SEL sel, Class arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("#", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_256(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	Class objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("#", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8*12@16*20@24i28 */
static char 
meth_imp_257(id self, SEL sel, char* arg_2, id arg_3, char* arg_4, id arg_5, int arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_257(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	char* objc_arg2;
	id objc_arg3;
	char* objc_arg4;
	id objc_arg5;
	int objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8*12I16 */
static char 
meth_imp_258(id self, SEL sel, char* arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_258(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	char* objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8*12I16@20 */
static char 
meth_imp_259(id self, SEL sel, char* arg_2, unsigned int arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_259(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	char* objc_arg2;
	unsigned int objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8*12I16I20 */
static char 
meth_imp_260(id self, SEL sel, char* arg_2, unsigned int arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_260(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	char* objc_arg2;
	unsigned int objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8*12i16c20c24c28 */
static char 
meth_imp_261(id self, SEL sel, char* arg_2, int arg_3, char arg_4, char arg_5, char arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_261(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	char* objc_arg2;
	int objc_arg3;
	char objc_arg4;
	char objc_arg5;
	char objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8:12 */
static char 
meth_imp_262(id self, SEL sel, SEL arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_262(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	SEL objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8:12@16 */
static char 
meth_imp_263(id self, SEL sel, SEL arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_263(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	SEL objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8:12@16@20 */
static char 
meth_imp_264(id self, SEL sel, SEL arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_264(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	SEL objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8:12@16i20i24 */
static char 
meth_imp_265(id self, SEL sel, SEL arg_2, id arg_3, int arg_4, int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_265(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	SEL objc_arg2;
	id objc_arg3;
	int objc_arg4;
	int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12 */
static char 
meth_imp_266(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_266(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12:16 */
static char 
meth_imp_267(id self, SEL sel, id arg_2, SEL arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_267(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	SEL objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12@16 */
static char 
meth_imp_268(id self, SEL sel, id arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_268(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12@16:20 */
static char 
meth_imp_269(id self, SEL sel, id arg_2, id arg_3, SEL arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_269(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	SEL objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12@16@20 */
static char 
meth_imp_270(id self, SEL sel, id arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_270(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


// Skipped complex signature: c0@4:8@12@16@20@24^i28
/* signature: c0@4:8@12@16@20I24 */
static char 
meth_imp_271(id self, SEL sel, id arg_2, id arg_3, id arg_4, unsigned int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_271(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	unsigned int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12@16@20i24 */
static char 
meth_imp_272(id self, SEL sel, id arg_2, id arg_3, id arg_4, int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_272(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12@16I20 */
static char 
meth_imp_273(id self, SEL sel, id arg_2, id arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_273(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12@16S20 */
static char 
meth_imp_274(id self, SEL sel, id arg_2, id arg_3, unsigned short arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_274(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	unsigned short objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


// Skipped complex signature: c0@4:8@12@16^@20
// Skipped complex signature: c0@4:8@12@16^c20
// Skipped complex signature: c0@4:8@12@16^{_NSZone=}20
// Skipped complex signature: c0@4:8@12@16^{_NSZone=}20@24
/* signature: c0@4:8@12@16c20 */
static char 
meth_imp_275(id self, SEL sel, id arg_2, id arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_275(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12@16c20c24 */
static char 
meth_imp_276(id self, SEL sel, id arg_2, id arg_3, char arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_276(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	char objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12@16c20c24c28 */
static char 
meth_imp_277(id self, SEL sel, id arg_2, id arg_3, char arg_4, char arg_5, char arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_277(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	char objc_arg4;
	char objc_arg5;
	char objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12@16i20 */
static char 
meth_imp_278(id self, SEL sel, id arg_2, id arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_278(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


// Skipped complex signature: c0@4:8@12@16i20^{_NSMapTable=}24@28
/* signature: c0@4:8@12@16{_NSPoint=ff}20@28 */
static char 
meth_imp_279(id self, SEL sel, id arg_2, id arg_3, struct _NSPoint arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_279(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct _NSPoint objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12I16 */
static char 
meth_imp_280(id self, SEL sel, id arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_280(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12I16@20@24I28 */
static char 
meth_imp_281(id self, SEL sel, id arg_2, unsigned int arg_3, id arg_4, id arg_5, unsigned int arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_281(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	unsigned int objc_arg3;
	id objc_arg4;
	id objc_arg5;
	unsigned int objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


// Skipped complex signature: c0@4:8@12I16^@20@24c28
// Skipped complex signature: c0@4:8@12^@16^@20
// Skipped complex signature: c0@4:8@12^^S16^^f20
// Skipped complex signature: c0@4:8@12^c16
// Skipped complex signature: c0@4:8@12^c16^c20^c24^@28^@32
// Skipped complex signature: c0@4:8@12^{FSRef=[80C]}16c20c24
// Skipped complex signature: c0@4:8@12^{_NSRect={_NSPoint=ff}{_NSSize=ff}}16^c20
/* signature: c0@4:8@12c16 */
static char 
meth_imp_282(id self, SEL sel, id arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_282(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12c16c20 */
static char 
meth_imp_283(id self, SEL sel, id arg_2, char arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_283(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	char objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12i16 */
static char 
meth_imp_284(id self, SEL sel, id arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_284(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12i16@20 */
static char 
meth_imp_285(id self, SEL sel, id arg_2, int arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_285(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	int objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


// Skipped complex signature: c0@4:8@12i16^c20^c24^@28
/* signature: c0@4:8@12o^c16 */
static char 
meth_imp_286(id self, SEL sel, id arg_2, char  *arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 2) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("c", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("c", v, arg_3);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_286(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(2);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("c", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("c", &objc_arg3);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		return result_list;
	}
}


/* signature: c0@4:8@12r^{FSRef=[80C]}16r^{FSRef=[80C]}20 */
static char 
meth_imp_287(id self, SEL sel, id arg_2, struct FSRef  *arg_3, struct FSRef  *arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{FSRef=[80C]}", arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{FSRef=[80C]}", arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_287(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	struct FSRef objc_arg3;
	struct FSRef objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{FSRef=[80C]}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{FSRef=[80C]}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12r^{FSRef=[80C]}16r^{FSRef=[80C]}20@24i28 */
static char 
meth_imp_288(id self, SEL sel, id arg_2, struct FSRef  *arg_3, struct FSRef  *arg_4, id arg_5, int arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{FSRef=[80C]}", arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{FSRef=[80C]}", arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_288(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	struct FSRef objc_arg3;
	struct FSRef objc_arg4;
	id objc_arg5;
	int objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{FSRef=[80C]}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{FSRef=[80C]}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}16 */
static char 
meth_imp_289(id self, SEL sel, id arg_2, struct _NSRect  *arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_289(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	struct _NSRect objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}16i20 */
static char 
meth_imp_290(id self, SEL sel, id arg_2, struct _NSRect  *arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_290(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	struct _NSRect objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12{_NSPoint=ff}16 */
static char 
meth_imp_291(id self, SEL sel, id arg_2, struct _NSPoint arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_291(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	struct _NSPoint objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12{_NSRange=II}16 */
static char 
meth_imp_292(id self, SEL sel, id arg_2, struct _NSRange arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_292(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	struct _NSRange objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12{_NSRange=II}16@24 */
static char 
meth_imp_293(id self, SEL sel, id arg_2, struct _NSRange arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_293(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	struct _NSRange objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16 */
static char 
meth_imp_294(id self, SEL sel, id arg_2, struct _NSRect arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_294(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	struct _NSRect objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32 */
static char 
meth_imp_295(id self, SEL sel, id arg_2, struct _NSRect arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_295(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	struct _NSRect objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16c32 */
static char 
meth_imp_296(id self, SEL sel, id arg_2, struct _NSRect arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_296(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	struct _NSRect objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8C12 */
static char 
meth_imp_297(id self, SEL sel, unsigned char arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("C", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_297(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	unsigned char objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("C", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8I12 */
static char 
meth_imp_298(id self, SEL sel, unsigned int arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_298(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	unsigned int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8I12I16 */
static char 
meth_imp_299(id self, SEL sel, unsigned int arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_299(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	unsigned int objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8I12I16@20 */
static char 
meth_imp_300(id self, SEL sel, unsigned int arg_2, unsigned int arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_300(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	unsigned int objc_arg2;
	unsigned int objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8I12{_NSPoint=ff}16I24@28 */
static char 
meth_imp_301(id self, SEL sel, unsigned int arg_2, struct _NSPoint arg_3, unsigned int arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_301(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	unsigned int objc_arg2;
	struct _NSPoint objc_arg3;
	unsigned int objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8L12 */
static char 
meth_imp_302(id self, SEL sel, unsigned long arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("L", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_302(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	unsigned long objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("L", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8S12 */
static char 
meth_imp_303(id self, SEL sel, unsigned short arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_303(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	unsigned short objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


// Skipped complex signature: c0@4:8^*12
// Skipped complex signature: c0@4:8^*12@16
// Skipped complex signature: c0@4:8^@12
// Skipped complex signature: c0@4:8^@12@16
// Skipped complex signature: c0@4:8^@12@16I20@24
// Skipped complex signature: c0@4:8^@12I16
// Skipped complex signature: c0@4:8^@12^I16
// Skipped complex signature: c0@4:8^@12^{_NSRange=II}16@20{_NSRange=II}24^@32
// Skipped complex signature: c0@4:8^I12^{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@20
// Skipped complex signature: c0@4:8^i12
// Skipped complex signature: c0@4:8^i12@16@20i24c28c32
// Skipped complex signature: c0@4:8^i12^i16@20
// Skipped complex signature: c0@4:8^i12^i16@20r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}24
// Skipped complex signature: c0@4:8^i12^i16{_NSPoint=ff}20
// Skipped complex signature: c0@4:8^i12{_NSSize=ff}16f40
// Skipped complex signature: c0@4:8^s12
// Skipped complex signature: c0@4:8^v12
// Skipped complex signature: c0@4:8^{ATSGlyphVector=III^v*I^v^{ATSStyleSetting}SsiiI{FixedRect=iiii}IiiiSS^S^s^s^i^i}12{_NSRange=II}16c24^f28^f32
// Skipped complex signature: c0@4:8^{ATSGlyphVector=III^v*I^v^{ATSStyleSetting}SsiiI{FixedRect=iiii}IiiiSS^S^s^s^i^i}12{_NSRange=II}16f40
// Skipped complex signature: c0@4:8^{FSRef=[80C]}12
// Skipped complex signature: c0@4:8^{FSRef=[80C]}12@16
// Skipped complex signature: c0@4:8^{FSSpec=sl[64C]}12
// Skipped complex signature: c0@4:8^{_NSPoint=ff}12
// Skipped complex signature: c0@4:8^{_NSPoint=ff}12c16
// Skipped complex signature: c0@4:8^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12c16
// Skipped complex signature: c0@4:8^{_NSSize=ff}12c16
// Skipped complex signature: c0@4:8^{tiff=*^{_NXStream}sccsll{?=IIIIIISSSSSSSSSSIIIffSSffII[2S]ISSSSI^S^S^S^S[3^S]*********[2I]II^I^I[2S]^f[2S]S^f^f^f[4^S]S[2S]**I^v}{?=SSL}^i^i[10i]liillil^?^?^?^?^?^?^?^?^?^?^?^?*ii*l*llii}12i16
/* signature: c0@4:8c12 */
static char 
meth_imp_304(id self, SEL sel, char arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_304(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	char objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8d40 */
static char 
meth_imp_305(id self, SEL sel, double arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_305(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	double objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


// Skipped complex signature: c0@4:8d40^v20@24@28I32
/* signature: c0@4:8f40 */
static char 
meth_imp_306(id self, SEL sel, float arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_306(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	float objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8f40c16 */
static char 
meth_imp_307(id self, SEL sel, float arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_307(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	float objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8i12 */
static char 
meth_imp_308(id self, SEL sel, int arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_308(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8i12@16 */
static char 
meth_imp_309(id self, SEL sel, int arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_309(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	int objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8i12@16@20 */
static char 
meth_imp_310(id self, SEL sel, int arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_310(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	int objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8i12@16@20@24 */
static char 
meth_imp_311(id self, SEL sel, int arg_2, id arg_3, id arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_311(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	int objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8i12c16 */
static char 
meth_imp_312(id self, SEL sel, int arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_312(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	int objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8i12f40r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}20r^{_NSPoint=ff}24 */
static char 
meth_imp_313(id self, SEL sel, int arg_2, float arg_3, struct _NSRect  *arg_4, struct _NSPoint  *arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_313(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	int objc_arg2;
	float objc_arg3;
	struct _NSRect objc_arg4;
	struct _NSPoint objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8i12i16 */
static char 
meth_imp_314(id self, SEL sel, int arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_314(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	int objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8i12i16i20 */
static char 
meth_imp_315(id self, SEL sel, int arg_2, int arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_315(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	int objc_arg2;
	int objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8l12 */
static char 
meth_imp_316(id self, SEL sel, long arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("l", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_316(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	long objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("l", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8nO@12nO@16 */
static char 
meth_imp_317(id self, SEL sel, id arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_317(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8r*12 */
static char 
meth_imp_318(id self, SEL sel, char* arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_318(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	char* objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


// Skipped complex signature: c0@4:8r^{?=@@cc}12I16@20^{?=@@cc}24^@28
/* signature: c0@4:8r^{FSRef=[80C]}12 */
static char 
meth_imp_319(id self, SEL sel, struct FSRef  *arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{FSRef=[80C]}", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_319(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct FSRef objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{FSRef=[80C]}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8r^{_NSPoint=ff}12 */
static char 
meth_imp_320(id self, SEL sel, struct _NSPoint  *arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_320(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct _NSPoint objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@16 */
static char 
meth_imp_321(id self, SEL sel, struct _NSRect  *arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_321(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct _NSRect objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12f40 */
static char 
meth_imp_322(id self, SEL sel, struct _NSRect  *arg_2, float arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_322(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct _NSRect objc_arg2;
	float objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8s12 */
static char 
meth_imp_323(id self, SEL sel, short arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("s", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_323(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	short objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("s", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


// Skipped complex signature: c0@4:8s12r^{FSRef=[80C]}16^{FSRef=[80C]}20
/* signature: c0@4:8{NSButtonState=iccc}12 */
static char 
meth_imp_324(id self, SEL sel, struct NSButtonState arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{NSButtonState=iccc}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_324(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct NSButtonState objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{NSButtonState=iccc}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8{_NSPoint=ff}12 */
static char 
meth_imp_325(id self, SEL sel, struct _NSPoint arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_325(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct _NSPoint objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8{_NSPoint=ff}12@20 */
static char 
meth_imp_326(id self, SEL sel, struct _NSPoint arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_326(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct _NSPoint objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


// Skipped complex signature: c0@4:8{_NSPoint=ff}12^i20^i24
/* signature: c0@4:8{_NSPoint=ff}12i20 */
static char 
meth_imp_327(id self, SEL sel, struct _NSPoint arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_327(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct _NSPoint objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8{_NSPoint=ff}12{_NSPoint=ff}20@28 */
static char 
meth_imp_328(id self, SEL sel, struct _NSPoint arg_2, struct _NSPoint arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_328(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct _NSPoint objc_arg2;
	struct _NSPoint objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8{_NSPoint=ff}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}20 */
static char 
meth_imp_329(id self, SEL sel, struct _NSPoint arg_2, struct _NSRect arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_329(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct _NSPoint objc_arg2;
	struct _NSRect objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12 */
static char 
meth_imp_330(id self, SEL sel, struct _NSRect arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_330(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct _NSRect objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28 */
static char 
meth_imp_331(id self, SEL sel, struct _NSRect arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_331(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct _NSRect objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28@32 */
static char 
meth_imp_332(id self, SEL sel, struct _NSRect arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_332(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct _NSRect objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


// Skipped complex signature: c36@4:8@12^{FSRef=[80C]}16@20^{FSRef=[80C]}24i28^{_NSMapTable=}32@32
/* signature: c36@4:8@12i16i20c24c28c32c35 */
static char 
meth_imp_333(id self, SEL sel, id arg_2, int arg_3, int arg_4, char arg_5, char arg_6, char arg_7, char arg_8)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(8);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_333(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	int objc_arg3;
	int objc_arg4;
	char objc_arg5;
	char objc_arg6;
	char objc_arg7;
	char objc_arg8;
	struct objc_super super;

	if (PyTuple_Size(args) != 7) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c36@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32I32 */
static char 
meth_imp_334(id self, SEL sel, id arg_2, struct _NSRect arg_3, id arg_4, unsigned int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_334(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	struct _NSRect objc_arg3;
	id objc_arg4;
	unsigned int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c36@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32c35 */
static char 
meth_imp_335(id self, SEL sel, id arg_2, struct _NSRect arg_3, id arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_335(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	struct _NSRect objc_arg3;
	id objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c36@4:8{_NSRange=II}12{_NSRange=II}20{_NSRange=II}28@32 */
static char 
meth_imp_336(id self, SEL sel, struct _NSRange arg_2, struct _NSRange arg_3, struct _NSRange arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_336(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct _NSRange objc_arg2;
	struct _NSRange objc_arg3;
	struct _NSRange objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28i32i32 */
static char 
meth_imp_337(id self, SEL sel, struct _NSRect arg_2, id arg_3, int arg_4, int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_337(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct _NSRect objc_arg2;
	id objc_arg3;
	int objc_arg4;
	int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


// Skipped complex signature: c40@4:8*12I16^I20I24c28{_NSRange=II}28^{_NSRange=II}36
/* signature: c40@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32I32c39 */
static char 
meth_imp_338(id self, SEL sel, id arg_2, struct _NSRect arg_3, id arg_4, unsigned int arg_5, char arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_338(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	struct _NSRect objc_arg3;
	id objc_arg4;
	unsigned int objc_arg5;
	char objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


/* signature: c40@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32c35@36 */
static char 
meth_imp_339(id self, SEL sel, id arg_2, struct _NSRect arg_3, id arg_4, char arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_339(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	struct _NSRect objc_arg3;
	id objc_arg4;
	char objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


// Skipped complex signature: c40@4:8^@12I16^I20I24c28{_NSRange=II}28^{_NSRange=II}36
/* signature: c40@4:8d40@20@24@28@32I32I36 */
static char 
meth_imp_340(id self, SEL sel, double arg_2, id arg_3, id arg_4, id arg_5, id arg_6, unsigned int arg_7, unsigned int arg_8)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(8);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_340(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	double objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	unsigned int objc_arg7;
	unsigned int objc_arg8;
	struct objc_super super;

	if (PyTuple_Size(args) != 7) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


// Skipped complex signature: c56@4:8@12{_NSSize=ff}16f40{_NSRect={_NSPoint=ff}{_NSSize=ff}}24@40c47c51^{_NSSize=ff}52
// Skipped complex signature: c60@4:8@12@16{_NSSize=ff}20f40{_NSRect={_NSPoint=ff}{_NSSize=ff}}28@44c51c55^{_NSSize=ff}56
/* signature: c60@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}24i40f40c51c55c59 */
static char 
meth_imp_341(id self, SEL sel, struct _NSRect arg_2, struct _NSRect arg_3, int arg_4, float arg_5, char arg_6, char arg_7, char arg_8)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(8);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("c", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_341(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	struct _NSRect objc_arg2;
	struct _NSRect objc_arg3;
	int objc_arg4;
	float objc_arg5;
	char objc_arg6;
	char objc_arg7;
	char objc_arg8;
	struct objc_super super;

	if (PyTuple_Size(args) != 7) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("c", &objc_retval);
	return v;
}


// Skipped complex signature: c72@4:8@12i16@20@24{_NSSize=ff}28f40{_NSRect={_NSPoint=ff}{_NSSize=ff}}36@52@56c63c67^{_NSSize=ff}68
// Skipped complex signature: c84@4:8^S12I16@20@24{_NSSize=ff}28{_NSRect={_NSPoint=ff}{_NSSize=ff}}32{_NSPoint=ff}48{_NSRect={_NSPoint=ff}{_NSSize=ff}}56@72@76c83
/* signature: c@:@o^@ */
static char 
meth_imp_342(id self, SEL sel, id arg_2, id  *arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 2) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("c", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("@", v, arg_3);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_342(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(2);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("c", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("@", &objc_arg3);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		return result_list;
	}
}


/* signature: c@:@o^@o^@ */
static char 
meth_imp_343(id self, SEL sel, id arg_2, id  *arg_3, id  *arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 3) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("c", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("@", v, arg_3);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 2);
		errstr = ObjC_PythonToObjC("@", v, arg_4);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_343(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(3);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("c", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("@", &objc_arg3);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		v = ObjC_ObjCToPython("@", &objc_arg4);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 2, v);
		return result_list;
	}
}


/* signature: c@:o^@@o^@ */
static char 
meth_imp_344(id self, SEL sel, id  *arg_2, id arg_3, id  *arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 3) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("c", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("@", v, arg_2);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 2);
		errstr = ObjC_PythonToObjC("@", v, arg_4);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_344(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(3);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("c", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("@", &objc_arg2);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		v = ObjC_ObjCToPython("@", &objc_arg4);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 2, v);
		return result_list;
	}
}


/* signature: c@:o^I */
static char 
meth_imp_345(id self, SEL sel, unsigned int  *arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 2) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("c", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("I", v, arg_2);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_345(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	unsigned int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(2);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("c", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("I", &objc_arg2);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		return result_list;
	}
}


/* signature: c@:o^d */
static char 
meth_imp_346(id self, SEL sel, double  *arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 2) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("c", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("d", v, arg_2);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_346(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	double objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(2);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("c", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("d", &objc_arg2);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		return result_list;
	}
}


/* signature: c@:o^f */
static char 
meth_imp_347(id self, SEL sel, float  *arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 2) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("c", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("f", v, arg_2);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_347(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	float objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(2);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("c", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("f", &objc_arg2);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		return result_list;
	}
}


/* signature: c@:o^i */
static char 
meth_imp_348(id self, SEL sel, int  *arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 2) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("c", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("i", v, arg_2);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_348(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(2);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("c", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("i", &objc_arg2);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		return result_list;
	}
}


/* signature: c@:o^q */
static char 
meth_imp_349(id self, SEL sel, long long  *arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 2) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("c", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("q", v, arg_2);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_349(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	long long objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(2);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("c", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("q", &objc_arg2);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		return result_list;
	}
}


/* signature: d0@4:8 */
static double 
meth_imp_350(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	double objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("d", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_350(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	double objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (double)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("d", &objc_retval);
	return v;
}


/* signature: d0@4:8@12 */
static double 
meth_imp_351(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	double objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("d", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_351(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	double objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (double)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("d", &objc_retval);
	return v;
}


/* signature: d0@4:8d40 */
static double 
meth_imp_352(id self, SEL sel, double arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	double objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("d", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_352(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	double objc_retval;
	double objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (double)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("d", &objc_retval);
	return v;
}


/* signature: d0@4:8i12 */
static double 
meth_imp_353(id self, SEL sel, int arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	double objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("d", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_353(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	double objc_retval;
	int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (double)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("d", &objc_retval);
	return v;
}


/* signature: d0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12 */
static double 
meth_imp_354(id self, SEL sel, struct _NSRect arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	double objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("d", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_354(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	double objc_retval;
	struct _NSRect objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (double)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("d", &objc_retval);
	return v;
}


/* signature: f0@4:8 */
static float 
meth_imp_355(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_355(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (float)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("f", &objc_retval);
	return v;
}


/* signature: f0@4:8@12 */
static float 
meth_imp_356(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_356(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (float)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("f", &objc_retval);
	return v;
}


/* signature: f0@4:8@12@16 */
static float 
meth_imp_357(id self, SEL sel, id arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_357(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (float)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("f", &objc_retval);
	return v;
}


/* signature: f0@4:8@12@16f40 */
static float 
meth_imp_358(id self, SEL sel, id arg_2, id arg_3, float arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_358(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_retval;
	id objc_arg2;
	id objc_arg3;
	float objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (float)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("f", &objc_retval);
	return v;
}


/* signature: f0@4:8@12I16 */
static float 
meth_imp_359(id self, SEL sel, id arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_359(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_retval;
	id objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (float)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("f", &objc_retval);
	return v;
}


/* signature: f0@4:8@12f40i20 */
static float 
meth_imp_360(id self, SEL sel, id arg_2, float arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_360(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_retval;
	id objc_arg2;
	float objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (float)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("f", &objc_retval);
	return v;
}


/* signature: f0@4:8@12i16 */
static float 
meth_imp_361(id self, SEL sel, id arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_361(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_retval;
	id objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (float)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("f", &objc_retval);
	return v;
}


/* signature: f0@4:8I12 */
static float 
meth_imp_362(id self, SEL sel, unsigned int arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_362(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_retval;
	unsigned int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (float)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("f", &objc_retval);
	return v;
}


/* signature: f0@4:8c12 */
static float 
meth_imp_363(id self, SEL sel, char arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_363(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_retval;
	char objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (float)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("f", &objc_retval);
	return v;
}


/* signature: f0@4:8c12f40 */
static float 
meth_imp_364(id self, SEL sel, char arg_2, float arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_364(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_retval;
	char objc_arg2;
	float objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (float)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("f", &objc_retval);
	return v;
}


/* signature: f0@4:8d40 */
static float 
meth_imp_365(id self, SEL sel, double arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_365(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_retval;
	double objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (float)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("f", &objc_retval);
	return v;
}


/* signature: f0@4:8f40 */
static float 
meth_imp_366(id self, SEL sel, float arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_366(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_retval;
	float objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (float)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("f", &objc_retval);
	return v;
}


/* signature: f0@4:8i12 */
static float 
meth_imp_367(id self, SEL sel, int arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_367(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_retval;
	int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (float)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("f", &objc_retval);
	return v;
}


/* signature: f0@4:8r*12I16 */
static float 
meth_imp_368(id self, SEL sel, char* arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_368(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_retval;
	char* objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (float)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("f", &objc_retval);
	return v;
}


/* signature: f0@4:8{_NSPoint=ff}12@20 */
static float 
meth_imp_369(id self, SEL sel, struct _NSPoint arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_369(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_retval;
	struct _NSPoint objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (float)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("f", &objc_retval);
	return v;
}


/* signature: f0@4:8{_NSSize=ff}12 */
static float 
meth_imp_370(id self, SEL sel, struct _NSSize arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_370(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_retval;
	struct _NSSize objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (float)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("f", &objc_retval);
	return v;
}


/* signature: i0@4:8 */
static int 
meth_imp_371(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_371(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8*12 */
static int 
meth_imp_372(id self, SEL sel, char* arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_372(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	char* objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8*12@16 */
static int 
meth_imp_373(id self, SEL sel, char* arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_373(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	char* objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12 */
static int 
meth_imp_374(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_374(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12:16 */
static int 
meth_imp_375(id self, SEL sel, id arg_2, SEL arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_375(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	SEL objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12@16 */
static int 
meth_imp_376(id self, SEL sel, id arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_376(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12@16@20 */
static int 
meth_imp_377(id self, SEL sel, id arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_377(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12@16@20@24 */
static int 
meth_imp_378(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_378(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12@16@20@24@28@32 */
static int 
meth_imp_379(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5, id arg_6, id arg_7)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(7);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_379(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	id objc_arg7;
	struct objc_super super;

	if (PyTuple_Size(args) != 6) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


// Skipped complex signature: i0@4:8@12@16@20@24^@28
/* signature: i0@4:8@12@16@20c24 */
static int 
meth_imp_380(id self, SEL sel, id arg_2, id arg_3, id arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_380(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


// Skipped complex signature: i0@4:8@12@16^?20^v24
/* signature: i0@4:8@12@16c20 */
static int 
meth_imp_381(id self, SEL sel, id arg_2, id arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_381(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	id objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12@16c20c24 */
static int 
meth_imp_382(id self, SEL sel, id arg_2, id arg_3, char arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_382(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	id objc_arg3;
	char objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12@16i20 */
static int 
meth_imp_383(id self, SEL sel, id arg_2, id arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_383(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	id objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12I16 */
static int 
meth_imp_384(id self, SEL sel, id arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_384(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12I16{_NSRange=II}20 */
static int 
meth_imp_385(id self, SEL sel, id arg_2, unsigned int arg_3, struct _NSRange arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_385(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	unsigned int objc_arg3;
	struct _NSRange objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12I16{_NSRange=II}20@28 */
static int 
meth_imp_386(id self, SEL sel, id arg_2, unsigned int arg_3, struct _NSRange arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_386(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	unsigned int objc_arg3;
	struct _NSRange objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


// Skipped complex signature: i0@4:8@12^S16^i20^{_NSSortState=iIIII[4@]}24
// Skipped complex signature: i0@4:8@12^i16
/* signature: i0@4:8@12c16 */
static int 
meth_imp_387(id self, SEL sel, id arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_387(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12c16@20 */
static int 
meth_imp_388(id self, SEL sel, id arg_2, char arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_388(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	char objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12c16@20@24@28 */
static int 
meth_imp_389(id self, SEL sel, id arg_2, char arg_3, id arg_4, id arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_389(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	char objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12c16c20 */
static int 
meth_imp_390(id self, SEL sel, id arg_2, char arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_390(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	char objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12i16 */
static int 
meth_imp_391(id self, SEL sel, id arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_391(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12i16c20 */
static int 
meth_imp_392(id self, SEL sel, id arg_2, int arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_392(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	int objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8@12{_NSRange=II}16 */
static int 
meth_imp_393(id self, SEL sel, id arg_2, struct _NSRange arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_393(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	struct _NSRange objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8I12 */
static int 
meth_imp_394(id self, SEL sel, unsigned int arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_394(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	unsigned int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8S12 */
static int 
meth_imp_395(id self, SEL sel, unsigned short arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_395(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	unsigned short objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8S12i16 */
static int 
meth_imp_396(id self, SEL sel, unsigned short arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_396(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	unsigned short objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


// Skipped complex signature: i0@4:8^@12
// Skipped complex signature: i0@4:8^I12
// Skipped complex signature: i0@4:8^I12i16^{_NSPoint=ff}20
// Skipped complex signature: i0@4:8^{OpaqueEventRef=}12{Point=ss}16s20I24
// Skipped complex signature: i0@4:8^{_NSModalSession=@@^{_NSModalSession}iciI^vi@@:^vi}12
// Skipped complex signature: i0@4:8^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12^f16
// Skipped complex signature: i0@4:8^{__sFILE=*iiss{__sbuf=*i}i^v^?^?^?^?{__sbuf=*i}*i[3C][1C]{__sbuf=*i}iq}12i16
/* signature: i0@4:8c12@16@20@24 */
static int 
meth_imp_397(id self, SEL sel, char arg_2, id arg_3, id arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_397(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	char objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8d40 */
static int 
meth_imp_398(id self, SEL sel, double arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_398(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	double objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8f40 */
static int 
meth_imp_399(id self, SEL sel, float arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_399(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	float objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8i12 */
static int 
meth_imp_400(id self, SEL sel, int arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_400(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8i12@16 */
static int 
meth_imp_401(id self, SEL sel, int arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_401(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	int objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8i12I16 */
static int 
meth_imp_402(id self, SEL sel, int arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_402(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	int objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


// Skipped complex signature: i0@4:8i12^{_NSPoint=ff}16
/* signature: i0@4:8i12c16@20 */
static int 
meth_imp_403(id self, SEL sel, int arg_2, char arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_403(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	int objc_arg2;
	char objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8i12f40 */
static int 
meth_imp_404(id self, SEL sel, int arg_2, float arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_404(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	int objc_arg2;
	float objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8i12i16 */
static int 
meth_imp_405(id self, SEL sel, int arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_405(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	int objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8i12i16@20 */
static int 
meth_imp_406(id self, SEL sel, int arg_2, int arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_406(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	int objc_arg2;
	int objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8i12{_NSPoint=ff}16 */
static int 
meth_imp_407(id self, SEL sel, int arg_2, struct _NSPoint arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_407(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	int objc_arg2;
	struct _NSPoint objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8i12{_NSPoint=ff}16@24i28 */
static int 
meth_imp_408(id self, SEL sel, int arg_2, struct _NSPoint arg_3, id arg_4, int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_408(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	int objc_arg2;
	struct _NSPoint objc_arg3;
	id objc_arg4;
	int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8n@12 */
static int 
meth_imp_409(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_409(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


// Skipped complex signature: i0@4:8r*12^i16
/* signature: i0@4:8r^{_NSPoint=ff}12 */
static int 
meth_imp_410(id self, SEL sel, struct _NSPoint  *arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_410(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	struct _NSPoint objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8{NSButtonState=iccc}12 */
static int 
meth_imp_411(id self, SEL sel, struct NSButtonState arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{NSButtonState=iccc}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_411(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	struct NSButtonState objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{NSButtonState=iccc}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8{_NSPoint=ff}12 */
static int 
meth_imp_412(id self, SEL sel, struct _NSPoint arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_412(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	struct _NSPoint objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12 */
static int 
meth_imp_413(id self, SEL sel, struct _NSRect arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_413(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	struct _NSRect objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


// Skipped complex signature: i0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28^v32
/* signature: i36@4:8@12@16i20c24c28c32c35 */
static int 
meth_imp_414(id self, SEL sel, id arg_2, id arg_3, int arg_4, char arg_5, char arg_6, char arg_7, char arg_8)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(8);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_414(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	id objc_arg3;
	int objc_arg4;
	char objc_arg5;
	char objc_arg6;
	char objc_arg7;
	char objc_arg8;
	struct objc_super super;

	if (PyTuple_Size(args) != 7) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: i36@4:8@12{_NSRange=II}16@24{_NSRange=II}28i32 */
static int 
meth_imp_415(id self, SEL sel, id arg_2, struct _NSRange arg_3, id arg_4, struct _NSRange arg_5, int arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_415(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	struct _NSRange objc_arg3;
	id objc_arg4;
	struct _NSRange objc_arg5;
	int objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


// Skipped complex signature: i36@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32^v32
// Skipped complex signature: i36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28^v32c35
// Skipped complex signature: i36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12c28@32^v32
/* signature: i40@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12c28@32@32@36 */
static int 
meth_imp_416(id self, SEL sel, struct _NSRect arg_2, char arg_3, id arg_4, id arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_416(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	struct _NSRect objc_arg2;
	char objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


// Skipped complex signature: i48@4:8@12@16@20{_NSRect={_NSPoint=ff}{_NSSize=ff}}20@36c43^v44
/* signature: i@:@ */
static int 
meth_imp_417(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_417(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (int)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("i", &objc_retval);
	return v;
}


/* signature: l0@4:8 */
static long 
meth_imp_418(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	long objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("l", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_418(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	long objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (long)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("l", &objc_retval);
	return v;
}


/* signature: l0@4:8i12r*16i20 */
static long 
meth_imp_419(id self, SEL sel, int arg_2, char* arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	long objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("l", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_419(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	long objc_retval;
	int objc_arg2;
	char* objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (long)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("l", &objc_retval);
	return v;
}


/* signature: q0@4:8 */
static long long 
meth_imp_420(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	long long objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("q", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_420(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	long long objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (long long)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("q", &objc_retval);
	return v;
}


// Skipped complex signature: q0@4:8:12^v16
/* signature: q0@4:8@12 */
static long long 
meth_imp_421(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	long long objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("q", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_421(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	long long objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (long long)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("q", &objc_retval);
	return v;
}


/* signature: r*0@4:8 */
static char* 
meth_imp_422(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char* objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("*", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_422(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char* objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (char*)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("*", &objc_retval);
	return v;
}


/* signature: r*0@4:8@12 */
static char* 
meth_imp_423(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char* objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("*", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_423(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char* objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char*)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("*", &objc_retval);
	return v;
}


// Skipped complex signature: r*0@4:8@12^I16
/* signature: r*0@4:8I12 */
static char* 
meth_imp_424(id self, SEL sel, unsigned int arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char* objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("*", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_424(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char* objc_retval;
	unsigned int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char*)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("*", &objc_retval);
	return v;
}


/* signature: r*0@4:8c12 */
static char* 
meth_imp_425(id self, SEL sel, char arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char* objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("*", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_425(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char* objc_retval;
	char objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char*)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("*", &objc_retval);
	return v;
}


/* signature: r^I0@4:8 */
static unsigned int  *
meth_imp_426(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned int  *objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("r^I", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_426(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int  *objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (unsigned int  *)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("r^I", &objc_retval);
	return v;
}


/* signature: r^S0@4:8 */
static unsigned short  *
meth_imp_427(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	unsigned short  *objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("r^S", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_427(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned short  *objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (unsigned short  *)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("r^S", &objc_retval);
	return v;
}


/* signature: r^f0@4:8 */
static float  *
meth_imp_428(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float  *objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("r^f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_428(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float  *objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (float  *)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("r^f", &objc_retval);
	return v;
}


/* signature: r^f0@4:8@12 */
static float  *
meth_imp_429(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	float  *objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("r^f", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_429(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float  *objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (float  *)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("r^f", &objc_retval);
	return v;
}


/* signature: r^i0@4:8 */
static int  *
meth_imp_430(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	int  *objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("r^i", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_430(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int  *objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (int  *)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("r^i", &objc_retval);
	return v;
}


// Skipped complex signature: r^v0@4:8
/* signature: r^{AEDesc=I^^{OpaqueAEDataStorageType}}0@4:8 */
static struct AEDesc  *
meth_imp_431(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	struct AEDesc  *objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("r^{AEDesc=I^^{OpaqueAEDataStorageType=}}", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_431(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct AEDesc  *objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (struct AEDesc  *)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("r^{AEDesc=I^^{OpaqueAEDataStorageType=}}", &objc_retval);
	return v;
}


/* signature: r^{FSRef=[80C]}0@4:8 */
static struct FSRef  *
meth_imp_432(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	struct FSRef  *objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("r^{FSRef=[80C]}", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_432(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct FSRef  *objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (struct FSRef  *)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("r^{FSRef=[80C]}", &objc_retval);
	return v;
}


/* signature: s0@4:8 */
static short 
meth_imp_433(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	short objc_retval;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("s", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_433(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	short objc_retval;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		objc_retval = (short)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("s", &objc_retval);
	return v;
}


/* signature: s0@4:8@12 */
static short 
meth_imp_434(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	short objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("s", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_434(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	short objc_retval;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (short)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("s", &objc_retval);
	return v;
}


/* signature: s0@4:8@12@16 */
static short 
meth_imp_435(id self, SEL sel, id arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	short objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("s", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_435(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	short objc_retval;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (short)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("s", &objc_retval);
	return v;
}


/* signature: s0@4:8@12@16@20 */
static short 
meth_imp_436(id self, SEL sel, id arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	short objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("s", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_436(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	short objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (short)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("s", &objc_retval);
	return v;
}


/* signature: s0@4:8L12@16 */
static short 
meth_imp_437(id self, SEL sel, unsigned long arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	short objc_retval;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("L", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("s", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_437(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	short objc_retval;
	unsigned long objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("L", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (short)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("s", &objc_retval);
	return v;
}


/* signature: s0@4:8L12@16@20 */
static short 
meth_imp_438(id self, SEL sel, unsigned long arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	short objc_retval;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("L", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	errstr = ObjC_PythonToObjC("s", retval, &objc_retval);
	Py_DECREF(retval);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
		ObjCErr_ToObjC();
	}
	return objc_retval;
}
static PyObject* super_438(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	short objc_retval;
	unsigned long objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("L", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (short)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	v = ObjC_ObjCToPython("s", &objc_retval);
	return v;
}


// Skipped complex signature: s0@4:8r^{AEDesc=I^^{OpaqueAEDataStorageType}}12^{AEDesc=I^^{OpaqueAEDataStorageType}}16I20
/* signature: v0@4:8 */
static void 
meth_imp_439(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_439(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8#12 */
static void 
meth_imp_440(id self, SEL sel, Class arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("#", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_440(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	Class objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("#", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8#12@16 */
static void 
meth_imp_441(id self, SEL sel, Class arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("#", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_441(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	Class objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("#", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8#12^v16
/* signature: v0@4:8*12 */
static void 
meth_imp_442(id self, SEL sel, char* arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_442(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char* objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8*12I16 */
static void 
meth_imp_443(id self, SEL sel, char* arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_443(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char* objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8*12I16{_NSRange=II}20^{_NSRange=II}28
/* signature: v0@4:8:12 */
static void 
meth_imp_444(id self, SEL sel, SEL arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_444(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	SEL objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8:12@16 */
static void 
meth_imp_445(id self, SEL sel, SEL arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_445(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	SEL objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8:12@16@20 */
static void 
meth_imp_446(id self, SEL sel, SEL arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_446(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	SEL objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8:12@16@20I24@28 */
static void 
meth_imp_447(id self, SEL sel, SEL arg_2, id arg_3, id arg_4, unsigned int arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_447(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	SEL objc_arg2;
	id objc_arg3;
	id objc_arg4;
	unsigned int objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8:12@16@20i24@28 */
static void 
meth_imp_448(id self, SEL sel, SEL arg_2, id arg_3, id arg_4, int arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_448(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	SEL objc_arg2;
	id objc_arg3;
	id objc_arg4;
	int objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8:12@16c20 */
static void 
meth_imp_449(id self, SEL sel, SEL arg_2, id arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_449(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	SEL objc_arg2;
	id objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8:12@16c20@24 */
static void 
meth_imp_450(id self, SEL sel, SEL arg_2, id arg_3, char arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_450(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	SEL objc_arg2;
	id objc_arg3;
	char objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8:12@16d40 */
static void 
meth_imp_451(id self, SEL sel, SEL arg_2, id arg_3, double arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_451(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	SEL objc_arg2;
	id objc_arg3;
	double objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8:12@16d40@28 */
static void 
meth_imp_452(id self, SEL sel, SEL arg_2, id arg_3, double arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_452(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	SEL objc_arg2;
	id objc_arg3;
	double objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8:12i16i20 */
static void 
meth_imp_453(id self, SEL sel, SEL arg_2, int arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_453(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	SEL objc_arg2;
	int objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12 */
static void 
meth_imp_454(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_454(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12#16 */
static void 
meth_imp_455(id self, SEL sel, id arg_2, Class arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("#", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_455(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	Class objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("#", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12:16 */
static void 
meth_imp_456(id self, SEL sel, id arg_2, SEL arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_456(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	SEL objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12:16#20 */
static void 
meth_imp_457(id self, SEL sel, id arg_2, SEL arg_3, Class arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("#", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_457(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	SEL objc_arg3;
	Class objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("#", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12:16#20#24 */
static void 
meth_imp_458(id self, SEL sel, id arg_2, SEL arg_3, Class arg_4, Class arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("#", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("#", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_458(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	SEL objc_arg3;
	Class objc_arg4;
	Class objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("#", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("#", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12:16@20 */
static void 
meth_imp_459(id self, SEL sel, id arg_2, SEL arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_459(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	SEL objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12:16@20@24 */
static void 
meth_imp_460(id self, SEL sel, id arg_2, SEL arg_3, id arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_460(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	SEL objc_arg3;
	id objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12:16@20@24I28 */
static void 
meth_imp_461(id self, SEL sel, id arg_2, SEL arg_3, id arg_4, id arg_5, unsigned int arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_461(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	SEL objc_arg3;
	id objc_arg4;
	id objc_arg5;
	unsigned int objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12:16@20@24i28 */
static void 
meth_imp_462(id self, SEL sel, id arg_2, SEL arg_3, id arg_4, id arg_5, int arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_462(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	SEL objc_arg3;
	id objc_arg4;
	id objc_arg5;
	int objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12:16I20 */
static void 
meth_imp_463(id self, SEL sel, id arg_2, SEL arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_463(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	SEL objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12:16I20I24 */
static void 
meth_imp_464(id self, SEL sel, id arg_2, SEL arg_3, unsigned int arg_4, unsigned int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_464(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	SEL objc_arg3;
	unsigned int objc_arg4;
	unsigned int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8@12:16^v20
/* signature: v0@4:8@12@16 */
static void 
meth_imp_465(id self, SEL sel, id arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_465(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16*20 */
static void 
meth_imp_466(id self, SEL sel, id arg_2, id arg_3, char* arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_466(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	char* objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8@12@16:20^v24
/* signature: v0@4:8@12@16@20 */
static void 
meth_imp_467(id self, SEL sel, id arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_467(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8@12@16@20:24^v28
/* signature: v0@4:8@12@16@20@24 */
static void 
meth_imp_468(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_468(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8@12@16@20@24:28^v32
/* signature: v0@4:8@12@16@20@24@28@32 */
static void 
meth_imp_469(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5, id arg_6, id arg_7)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(7);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_469(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	id objc_arg7;
	struct objc_super super;

	if (PyTuple_Size(args) != 6) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16@20@24c28 */
static void 
meth_imp_470(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5, char arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_470(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	char objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16@20I24 */
static void 
meth_imp_471(id self, SEL sel, id arg_2, id arg_3, id arg_4, unsigned int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_471(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	unsigned int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16@20I24@28 */
static void 
meth_imp_472(id self, SEL sel, id arg_2, id arg_3, id arg_4, unsigned int arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_472(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	unsigned int objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8@12@16@20^i24c28
/* signature: v0@4:8@12@16@20c24 */
static void 
meth_imp_473(id self, SEL sel, id arg_2, id arg_3, id arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_473(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16@20i24 */
static void 
meth_imp_474(id self, SEL sel, id arg_2, id arg_3, id arg_4, int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_474(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16@20i24c28 */
static void 
meth_imp_475(id self, SEL sel, id arg_2, id arg_3, id arg_4, int arg_5, char arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_475(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	int objc_arg5;
	char objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16I20 */
static void 
meth_imp_476(id self, SEL sel, id arg_2, id arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_476(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16I20@24 */
static void 
meth_imp_477(id self, SEL sel, id arg_2, id arg_3, unsigned int arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_477(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	unsigned int objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16L20 */
static void 
meth_imp_478(id self, SEL sel, id arg_2, id arg_3, unsigned long arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("L", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_478(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	unsigned long objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("L", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16c20 */
static void 
meth_imp_479(id self, SEL sel, id arg_2, id arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_479(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16c20c24 */
static void 
meth_imp_480(id self, SEL sel, id arg_2, id arg_3, char arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_480(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	char objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16f40@24@28 */
static void 
meth_imp_481(id self, SEL sel, id arg_2, id arg_3, float arg_4, id arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_481(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	float objc_arg4;
	id objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16i20 */
static void 
meth_imp_482(id self, SEL sel, id arg_2, id arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_482(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16i20@24 */
static void 
meth_imp_483(id self, SEL sel, id arg_2, id arg_3, int arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_483(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	int objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8@12@16i20@24:28^v32
/* signature: v0@4:8@12@16i20i24 */
static void 
meth_imp_484(id self, SEL sel, id arg_2, id arg_3, int arg_4, int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_484(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	int objc_arg4;
	int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16l20@24 */
static void 
meth_imp_485(id self, SEL sel, id arg_2, id arg_3, long arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("l", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_485(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	long objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("l", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16{_NSRange=II}20 */
static void 
meth_imp_486(id self, SEL sel, id arg_2, id arg_3, struct _NSRange arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_486(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	struct _NSRange objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12@16{_NSRect={_NSPoint=ff}{_NSSize=ff}}20 */
static void 
meth_imp_487(id self, SEL sel, id arg_2, id arg_3, struct _NSRect arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_487(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	struct _NSRect objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12I16 */
static void 
meth_imp_488(id self, SEL sel, id arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_488(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12I16@20 */
static void 
meth_imp_489(id self, SEL sel, id arg_2, unsigned int arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_489(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	unsigned int objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12I16@20*24 */
static void 
meth_imp_490(id self, SEL sel, id arg_2, unsigned int arg_3, id arg_4, char* arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_490(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	unsigned int objc_arg3;
	id objc_arg4;
	char* objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8@12I16I20^I24
/* signature: v0@4:8@12L16 */
static void 
meth_imp_491(id self, SEL sel, id arg_2, unsigned long arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("L", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_491(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	unsigned long objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("L", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8@12^@16^@20
// Skipped complex signature: v0@4:8@12^c16
// Skipped complex signature: v0@4:8@12^i16
// Skipped complex signature: v0@4:8@12^i16c20
// Skipped complex signature: v0@4:8@12^v16
// Skipped complex signature: v0@4:8@12^{?=^SI^SI^SI}16
// Skipped complex signature: v0@4:8@12^{__CFPasteboard=}16i20^v24
/* signature: v0@4:8@12c16 */
static void 
meth_imp_492(id self, SEL sel, id arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_492(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8@12c16@20:24^v28
// Skipped complex signature: v0@4:8@12c16^v20
/* signature: v0@4:8@12c16c20 */
static void 
meth_imp_493(id self, SEL sel, id arg_2, char arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_493(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	char objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12c16c20c24 */
static void 
meth_imp_494(id self, SEL sel, id arg_2, char arg_3, char arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_494(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	char objc_arg3;
	char objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12c16i20i24 */
static void 
meth_imp_495(id self, SEL sel, id arg_2, char arg_3, int arg_4, int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_495(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	char objc_arg3;
	int objc_arg4;
	int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12d40 */
static void 
meth_imp_496(id self, SEL sel, id arg_2, double arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_496(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	double objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12f40 */
static void 
meth_imp_497(id self, SEL sel, id arg_2, float arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_497(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	float objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12f40f48c24 */
static void 
meth_imp_498(id self, SEL sel, id arg_2, float arg_3, float arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_498(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	float objc_arg3;
	float objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12i16 */
static void 
meth_imp_499(id self, SEL sel, id arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_499(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12i16@20 */
static void 
meth_imp_500(id self, SEL sel, id arg_2, int arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_500(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	int objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8@12i16@20:24^v28
/* signature: v0@4:8@12i16I20 */
static void 
meth_imp_501(id self, SEL sel, id arg_2, int arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_501(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	int objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12i16I20@24 */
static void 
meth_imp_502(id self, SEL sel, id arg_2, int arg_3, unsigned int arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_502(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	int objc_arg3;
	unsigned int objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8@12i16^v20
/* signature: v0@4:8@12i16c20c24c28 */
static void 
meth_imp_503(id self, SEL sel, id arg_2, int arg_3, char arg_4, char arg_5, char arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_503(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	int objc_arg3;
	char objc_arg4;
	char objc_arg5;
	char objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12i16d40 */
static void 
meth_imp_504(id self, SEL sel, id arg_2, int arg_3, double arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_504(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	int objc_arg3;
	double objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12i16f40 */
static void 
meth_imp_505(id self, SEL sel, id arg_2, int arg_3, float arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_505(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	int objc_arg3;
	float objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12i16i20 */
static void 
meth_imp_506(id self, SEL sel, id arg_2, int arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_506(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	int objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12i16i20i24c28 */
static void 
meth_imp_507(id self, SEL sel, id arg_2, int arg_3, int arg_4, int arg_5, char arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_507(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	int objc_arg3;
	int objc_arg4;
	int objc_arg5;
	char objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12i16{_NSRange=II}20 */
static void 
meth_imp_508(id self, SEL sel, id arg_2, int arg_3, struct _NSRange arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_508(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	int objc_arg3;
	struct _NSRange objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12i16{_NSRect={_NSPoint=ff}{_NSSize=ff}}20 */
static void 
meth_imp_509(id self, SEL sel, id arg_2, int arg_3, struct _NSRect arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_509(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	int objc_arg3;
	struct _NSRect objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12l16 */
static void 
meth_imp_510(id self, SEL sel, id arg_2, long arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("l", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_510(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	long objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("l", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12s16 */
static void 
meth_imp_511(id self, SEL sel, id arg_2, short arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("s", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_511(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	short objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("s", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12{_NSPoint=ff}16 */
static void 
meth_imp_512(id self, SEL sel, id arg_2, struct _NSPoint arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_512(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSPoint objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12{_NSPoint=ff}16I24 */
static void 
meth_imp_513(id self, SEL sel, id arg_2, struct _NSPoint arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_513(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSPoint objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12{_NSPoint=ff}16{_NSPoint=ff}24 */
static void 
meth_imp_514(id self, SEL sel, id arg_2, struct _NSPoint arg_3, struct _NSPoint arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_514(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSPoint objc_arg3;
	struct _NSPoint objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12{_NSRange=II}16 */
static void 
meth_imp_515(id self, SEL sel, id arg_2, struct _NSRange arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_515(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSRange objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12{_NSRange=II}16@24 */
static void 
meth_imp_516(id self, SEL sel, id arg_2, struct _NSRange arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_516(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSRange objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12{_NSRange=II}16c24 */
static void 
meth_imp_517(id self, SEL sel, id arg_2, struct _NSRange arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_517(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSRange objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12{_NSRange=II}16{_NSRange=II}24 */
static void 
meth_imp_518(id self, SEL sel, id arg_2, struct _NSRange arg_3, struct _NSRange arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_518(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSRange objc_arg3;
	struct _NSRange objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16 */
static void 
meth_imp_519(id self, SEL sel, id arg_2, struct _NSRect arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_519(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSRect objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32 */
static void 
meth_imp_520(id self, SEL sel, id arg_2, struct _NSRect arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_520(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSRect objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16c32 */
static void 
meth_imp_521(id self, SEL sel, id arg_2, struct _NSRect arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_521(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSRect objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8@12{_NSSize=ff}16 */
static void 
meth_imp_522(id self, SEL sel, id arg_2, struct _NSSize arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_522(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSSize objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8C12 */
static void 
meth_imp_523(id self, SEL sel, unsigned char arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("C", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_523(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned char objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("C", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8I12 */
static void 
meth_imp_524(id self, SEL sel, unsigned int arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_524(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8I12@16 */
static void 
meth_imp_525(id self, SEL sel, unsigned int arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_525(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8I12@16@20 */
static void 
meth_imp_526(id self, SEL sel, unsigned int arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_526(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8I12I16 */
static void 
meth_imp_527(id self, SEL sel, unsigned int arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_527(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8I12I16I20 */
static void 
meth_imp_528(id self, SEL sel, unsigned int arg_2, unsigned int arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_528(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_arg2;
	unsigned int objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8I12Q16 */
static void 
meth_imp_529(id self, SEL sel, unsigned int arg_2, unsigned long long arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("Q", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_529(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_arg2;
	unsigned long long objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("Q", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8I12^v16
/* signature: v0@4:8I12{_NSPoint=ff}16I24@28 */
static void 
meth_imp_530(id self, SEL sel, unsigned int arg_2, struct _NSPoint arg_3, unsigned int arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_530(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_arg2;
	struct _NSPoint objc_arg3;
	unsigned int objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8I12{_NSRange=II}16 */
static void 
meth_imp_531(id self, SEL sel, unsigned int arg_2, struct _NSRange arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_531(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_arg2;
	struct _NSRange objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8I12{_NSRange=II}16i24 */
static void 
meth_imp_532(id self, SEL sel, unsigned int arg_2, struct _NSRange arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_532(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_arg2;
	struct _NSRange objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8I12{_NSRange=II}16i24{_NSRange=II}28 */
static void 
meth_imp_533(id self, SEL sel, unsigned int arg_2, struct _NSRange arg_3, int arg_4, struct _NSRange arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_533(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned int objc_arg2;
	struct _NSRange objc_arg3;
	int objc_arg4;
	struct _NSRange objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8L12 */
static void 
meth_imp_534(id self, SEL sel, unsigned long arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("L", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_534(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned long objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("L", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8L12@16L20 */
static void 
meth_imp_535(id self, SEL sel, unsigned long arg_2, id arg_3, unsigned long arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("L", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("L", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_535(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned long objc_arg2;
	id objc_arg3;
	unsigned long objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("L", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("L", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8Q12 */
static void 
meth_imp_536(id self, SEL sel, unsigned long long arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("Q", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_536(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned long long objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("Q", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8S12 */
static void 
meth_imp_537(id self, SEL sel, unsigned short arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_537(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned short objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8S12I16 */
static void 
meth_imp_538(id self, SEL sel, unsigned short arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("S", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_538(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned short objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8^*12
// Skipped complex signature: v0@4:8^?12^v16
// Skipped complex signature: v0@4:8^?12^v16{_NSRange=II}20
// Skipped complex signature: v0@4:8^@12
// Skipped complex signature: v0@4:8^@12^@16
// Skipped complex signature: v0@4:8^@12^i16
// Skipped complex signature: v0@4:8^@12^{_NSRange=II}16
// Skipped complex signature: v0@4:8^@12^{_NSRect={_NSPoint=ff}{_NSSize=ff}}16
// Skipped complex signature: v0@4:8^@12{_NSRange=II}16
// Skipped complex signature: v0@4:8^I12I16
// Skipped complex signature: v0@4:8^I12^I16
// Skipped complex signature: v0@4:8^I12^I16^I20{_NSRange=II}24
// Skipped complex signature: v0@4:8^I12i16@20
// Skipped complex signature: v0@4:8^S12
// Skipped complex signature: v0@4:8^S12^i16^{?=^SI^SI^SI}20
// Skipped complex signature: v0@4:8^S12{_NSRange=II}16
// Skipped complex signature: v0@4:8^^S12^i16
// Skipped complex signature: v0@4:8^^{OpaqueIconRef}12^s16
// Skipped complex signature: v0@4:8^^{OpaqueIconRef}12^s16@20
// Skipped complex signature: v0@4:8^f12
// Skipped complex signature: v0@4:8^f12^f16
// Skipped complex signature: v0@4:8^f12^f16^f20^f24
// Skipped complex signature: v0@4:8^f12^f16^f20^f24^f28
// Skipped complex signature: v0@4:8^f12^i16^f20
// Skipped complex signature: v0@4:8^i12I16
// Skipped complex signature: v0@4:8^i12I16I20
// Skipped complex signature: v0@4:8^i12I16^I20
// Skipped complex signature: v0@4:8^i12^f16
// Skipped complex signature: v0@4:8^i12^i16
// Skipped complex signature: v0@4:8^i12^i16{_NSPoint=ff}20
// Skipped complex signature: v0@4:8^i12c16
// Skipped complex signature: v0@4:8^l12i16
// Skipped complex signature: v0@4:8^l12i16i20
// Skipped complex signature: v0@4:8^v12
// Skipped complex signature: v0@4:8^v12@16@20
// Skipped complex signature: v0@4:8^v12I16
// Skipped complex signature: v0@4:8^v12I16I20
// Skipped complex signature: v0@4:8^v12I16^I20
// Skipped complex signature: v0@4:8^v12I16c20c24
// Skipped complex signature: v0@4:8^v12I16{?=ii}20
// Skipped complex signature: v0@4:8^v12^@16^@20^I24^@28
// Skipped complex signature: v0@4:8^v12i16
// Skipped complex signature: v0@4:8^v12l16l20l24
// Skipped complex signature: v0@4:8^v12r*16^I20@24
// Skipped complex signature: v0@4:8^v12{_NSRange=II}16
// Skipped complex signature: v0@4:8^v12{_NSRange=II}16c24
// Skipped complex signature: v0@4:8^{?=^{_NSModalSession}c@}12
// Skipped complex signature: v0@4:8^{?=ddd}12
// Skipped complex signature: v0@4:8^{ATSGlyphVector=III^v*I^v^{ATSStyleSetting}SsiiI{FixedRect=iiii}IiiiSS^S^s^s^i^i}12
// Skipped complex signature: v0@4:8^{ATSGlyphVector=III^v*I^v^{ATSStyleSetting}SsiiI{FixedRect=iiii}IiiiSS^S^s^s^i^i}12f40i20
// Skipped complex signature: v0@4:8^{ATSGlyphVector=III^v*I^v^{ATSStyleSetting}SsiiI{FixedRect=iiii}IiiiSS^S^s^s^i^i}12{_NSRange=II}16c24^c28^c32
// Skipped complex signature: v0@4:8^{ATSGlyphVector=III^v*I^v^{ATSStyleSetting}SsiiI{FixedRect=iiii}IiiiSS^S^s^s^i^i}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16I32
// Skipped complex signature: v0@4:8^{CGContext=}12
// Skipped complex signature: v0@4:8^{FSRef=[80C]}12
// Skipped complex signature: v0@4:8^{OpaqueCoreDrag=}12
// Skipped complex signature: v0@4:8^{OpaqueCoreDragHandler=}12
// Skipped complex signature: v0@4:8^{OpaqueIconRef=}12
// Skipped complex signature: v0@4:8^{OpaqueIconRef=}12s16
// Skipped complex signature: v0@4:8^{OpaqueMenuRef=}12
// Skipped complex signature: v0@4:8^{OpaqueRgnHandle=}12
// Skipped complex signature: v0@4:8^{_NSGlyphGenContext=iiiiiiiiiii@[32i][32i][32i][64i]{_NSRange=II}{_NSRange=II}ii^{_NSGlyphInsertBuffer}}12@16@20^{_NSRAStringBuffer=@IIIIII[100S]}24@28
// Skipped complex signature: v0@4:8^{_NSModalSession=@@^{_NSModalSession}iciI^vi@@:^vi}12
// Skipped complex signature: v0@4:8^{_NSModalSession=@@^{_NSModalSession}iciI^vi@@:^vi}12@16
// Skipped complex signature: v0@4:8^{_NSModalSession=@@^{_NSModalSession}iciI^vi@@:^vi}12c16
// Skipped complex signature: v0@4:8^{_NSPoint=ff}12i16
// Skipped complex signature: v0@4:8^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12
// Skipped complex signature: v0@4:8^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@16c20
// Skipped complex signature: v0@4:8^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12^{_NSRect={_NSPoint=ff}{_NSSize=ff}}16I20{_NSPoint=ff}24c32
// Skipped complex signature: v0@4:8^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12^{_NSRect={_NSPoint=ff}{_NSSize=ff}}16^{_NSRect={_NSPoint=ff}{_NSSize=ff}}20
// Skipped complex signature: v0@4:8^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12i16
// Skipped complex signature: v0@4:8^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16
// Skipped complex signature: v0@4:8^{_NSRefCountedRunArray=IIIIII[0{_NSRunArrayItem=I@}]}12
// Skipped complex signature: v0@4:8^{_NSSize=ff}12c16
// Skipped complex signature: v0@4:8^{_NSSortState=iIIII[4@]}12
// Skipped complex signature: v0@4:8^{_NSZone=}12
// Skipped complex signature: v0@4:8^{_NXStream=I**iilii^{stream_functions}^v}12i16f40
// Skipped complex signature: v0@4:8^{_PartStruct=if}12^I16{_NSRect={_NSPoint=ff}{_NSSize=ff}}20
// Skipped complex signature: v0@4:8^{__CFArray=}12c16
// Skipped complex signature: v0@4:8^{__CFBoolean=}12
// Skipped complex signature: v0@4:8^{__CFData=}12^{__CFData=}16^{__CFSocket=}20
// Skipped complex signature: v0@4:8^{__CFHTTPMessage=}12
// Skipped complex signature: v0@4:8^{__CFReadStream=}12
// Skipped complex signature: v0@4:8^{__CFReadStream=}12@16
// Skipped complex signature: v0@4:8^{__CFString=}12
// Skipped complex signature: v0@4:8^{__CFString=}12I16I20
// Skipped complex signature: v0@4:8^{jpeg_decompress_struct=^{jpeg_error_mgr}^{jpeg_memory_mgr}^{jpeg_progress_mgr}^vii^{jpeg_source_mgr}IIiiiIIdiiiiiiiiiiiiIIiiii^*IiIiI^[64i][4^{?}][4^{?}][4^{?}]i^{?}ii[16C][16C][16C]IiCCCSSiCi^{jpeg_marker_struct}iiiI*i[4^{?}]IIi[10i]iiiii^{jpeg_decomp_master}^{jpeg_d_main_controller}^{jpeg_d_coef_controller}^{jpeg_d_post_controller}^{jpeg_input_controller}^{jpeg_marker_reader}^{jpeg_entropy_decoder}^{jpeg_inverse_dct}^{jpeg_upsampler}^{jpeg_color_deconverter}^{jpeg_color_quantizer}}12
// Skipped complex signature: v0@4:8^{tiff=*^{_NXStream}sccsll{?=IIIIIISSSSSSSSSSIIIffSSffII[2S]ISSSSI^S^S^S^S[3^S]*********[2I]II^I^I[2S]^f[2S]S^f^f^f[4^S]S[2S]**I^v}{?=SSL}^i^i[10i]liillil^?^?^?^?^?^?^?^?^?^?^?^?*ii*l*llii}12
/* signature: v0@4:8c12 */
static void 
meth_imp_539(id self, SEL sel, char arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_539(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8c12@16 */
static void 
meth_imp_540(id self, SEL sel, char arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_540(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8c12@16@20@24 */
static void 
meth_imp_541(id self, SEL sel, char arg_2, id arg_3, id arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_541(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8c12I16 */
static void 
meth_imp_542(id self, SEL sel, char arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_542(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8c12I16I20 */
static void 
meth_imp_543(id self, SEL sel, char arg_2, unsigned int arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_543(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_arg2;
	unsigned int objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8c12I16^v20
// Skipped complex signature: v0@4:8c12I16r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}20r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}24^{_NSRect={_NSPoint=ff}{_NSSize=ff}}28
/* signature: v0@4:8c12c16 */
static void 
meth_imp_544(id self, SEL sel, char arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_544(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8c12c16c20 */
static void 
meth_imp_545(id self, SEL sel, char arg_2, char arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_545(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_arg2;
	char objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8c12f40 */
static void 
meth_imp_546(id self, SEL sel, char arg_2, float arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_546(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_arg2;
	float objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8c12i16i20 */
static void 
meth_imp_547(id self, SEL sel, char arg_2, int arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_547(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_arg2;
	int objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8c12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16 */
static void 
meth_imp_548(id self, SEL sel, char arg_2, struct _NSRect arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_548(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_arg2;
	struct _NSRect objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8c12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32 */
static void 
meth_imp_549(id self, SEL sel, char arg_2, struct _NSRect arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_549(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_arg2;
	struct _NSRect objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8d40 */
static void 
meth_imp_550(id self, SEL sel, double arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_550(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	double objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8d40@20 */
static void 
meth_imp_551(id self, SEL sel, double arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_551(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	double objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8d40c20 */
static void 
meth_imp_552(id self, SEL sel, double arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_552(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	double objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8d40d48 */
static void 
meth_imp_553(id self, SEL sel, double arg_2, double arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_553(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	double objc_arg2;
	double objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8f40 */
static void 
meth_imp_554(id self, SEL sel, float arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_554(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8f40@16 */
static void 
meth_imp_555(id self, SEL sel, float arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_555(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8f40@16@20@24 */
static void 
meth_imp_556(id self, SEL sel, float arg_2, id arg_3, id arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_556(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8f40c16 */
static void 
meth_imp_557(id self, SEL sel, float arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_557(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8f40f48 */
static void 
meth_imp_558(id self, SEL sel, float arg_2, float arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_558(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_arg2;
	float objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12 */
static void 
meth_imp_559(id self, SEL sel, int arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_559(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12@16 */
static void 
meth_imp_560(id self, SEL sel, int arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_560(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8i12@16:20^v24
/* signature: v0@4:8i12@16:20i24i28 */
static void 
meth_imp_561(id self, SEL sel, int arg_2, id arg_3, SEL arg_4, int arg_5, int arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython(":", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_561(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	id objc_arg3;
	SEL objc_arg4;
	int objc_arg5;
	int objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC(":", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12I16 */
static void 
meth_imp_562(id self, SEL sel, int arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_562(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8i12^{_NSGlyphGenContext=iiiiiiiiiii@[32i][32i][32i][64i]{_NSRange=II}{_NSRange=II}ii^{_NSGlyphInsertBuffer}}16@20@24^{_NSRAStringBuffer=@IIIIII[100S]}28@32
/* signature: v0@4:8i12c16 */
static void 
meth_imp_563(id self, SEL sel, int arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_563(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12c16c20 */
static void 
meth_imp_564(id self, SEL sel, int arg_2, char arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_564(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	char objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12c16c20c24 */
static void 
meth_imp_565(id self, SEL sel, int arg_2, char arg_3, char arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_565(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	char objc_arg3;
	char objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12f40 */
static void 
meth_imp_566(id self, SEL sel, int arg_2, float arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_566(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	float objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12f40f48f56 */
static void 
meth_imp_567(id self, SEL sel, int arg_2, float arg_3, float arg_4, float arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_567(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	float objc_arg3;
	float objc_arg4;
	float objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12i16 */
static void 
meth_imp_568(id self, SEL sel, int arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_568(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12i16@20 */
static void 
meth_imp_569(id self, SEL sel, int arg_2, int arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_569(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	int objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12i16@20c24 */
static void 
meth_imp_570(id self, SEL sel, int arg_2, int arg_3, id arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_570(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	int objc_arg3;
	id objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12i16I20 */
static void 
meth_imp_571(id self, SEL sel, int arg_2, int arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_571(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	int objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12i16c20 */
static void 
meth_imp_572(id self, SEL sel, int arg_2, int arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_572(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	int objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12i16c20c24c28 */
static void 
meth_imp_573(id self, SEL sel, int arg_2, int arg_3, char arg_4, char arg_5, char arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_573(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	int objc_arg3;
	char objc_arg4;
	char objc_arg5;
	char objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12i16c20c24c28c32 */
static void 
meth_imp_574(id self, SEL sel, int arg_2, int arg_3, char arg_4, char arg_5, char arg_6, char arg_7)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(7);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_574(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	int objc_arg3;
	char objc_arg4;
	char objc_arg5;
	char objc_arg6;
	char objc_arg7;
	struct objc_super super;

	if (PyTuple_Size(args) != 6) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12i16f40 */
static void 
meth_imp_575(id self, SEL sel, int arg_2, int arg_3, float arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_575(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	int objc_arg3;
	float objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12i16i20 */
static void 
meth_imp_576(id self, SEL sel, int arg_2, int arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_576(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	int objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12i16i20c24 */
static void 
meth_imp_577(id self, SEL sel, int arg_2, int arg_3, int arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_577(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	int objc_arg3;
	int objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12r*16i20 */
static void 
meth_imp_578(id self, SEL sel, int arg_2, char* arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_578(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	char* objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12{_NSRange=II}16 */
static void 
meth_imp_579(id self, SEL sel, int arg_2, struct _NSRange arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_579(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	struct _NSRange objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8i12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16 */
static void 
meth_imp_580(id self, SEL sel, int arg_2, struct _NSRect arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_580(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	struct _NSRect objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8l12 */
static void 
meth_imp_581(id self, SEL sel, long arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("l", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_581(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	long objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("l", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8q12@20 */
static void 
meth_imp_582(id self, SEL sel, long long arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("q", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_582(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	long long objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("q", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8r*12 */
static void 
meth_imp_583(id self, SEL sel, char* arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_583(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char* objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8r*12I16@20 */
static void 
meth_imp_584(id self, SEL sel, char* arg_2, unsigned int arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_584(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char* objc_arg2;
	unsigned int objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8r*12I16^v20
// Skipped complex signature: v0@4:8r*12I16r^v20
// Skipped complex signature: v0@4:8r*12^v16
/* signature: v0@4:8r*12i16 */
static void 
meth_imp_585(id self, SEL sel, char* arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_585(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char* objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8r*12r^v16
/* signature: v0@4:8r*12{_NSPoint=ff}16 */
static void 
meth_imp_586(id self, SEL sel, char* arg_2, struct _NSPoint arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_586(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char* objc_arg2;
	struct _NSPoint objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8r^S12I16 */
static void 
meth_imp_587(id self, SEL sel, unsigned short  *arg_2, unsigned int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("S", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_587(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	unsigned short objc_arg2;
	unsigned int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8r^^i12^i16
/* signature: v0@4:8r^f12f40 */
static void 
meth_imp_588(id self, SEL sel, float  *arg_2, float arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_588(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_arg2;
	float objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8r^f12i16f40 */
static void 
meth_imp_589(id self, SEL sel, float  *arg_2, int arg_3, float arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_589(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_arg2;
	int objc_arg3;
	float objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8r^i12i16 */
static void 
meth_imp_590(id self, SEL sel, int  *arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_590(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8r^v12
// Skipped complex signature: v0@4:8r^v12I16
// Skipped complex signature: v0@4:8r^v12I16@20
// Skipped complex signature: v0@4:8r^v12r*16@20
// Skipped complex signature: v0@4:8r^{ATSGlyphVector=III^v*I^v^{ATSStyleSetting}SsiiI{FixedRect=iiii}IiiiSS^S^s^s^i^i}12^{ATSGlyphVector=III^v*I^v^{ATSStyleSetting}SsiiI{FixedRect=iiii}IiiiSS^S^s^s^i^i}16I20
/* signature: v0@4:8r^{_NSPoint=ff}12@16 */
static void 
meth_imp_591(id self, SEL sel, struct _NSPoint  *arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_591(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{?=ii}12 */
struct pyobjcanonymous0 {
	unsigned short  *field_0;
	unsigned int field_1;
	unsigned short  *field_2;
	unsigned int field_3;
	unsigned short  *field_4;
	unsigned int field_5;
};

static void 
meth_imp_592(id self, SEL sel, struct pyobjcanonymous0 arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{pyobjcanonymous0=^SI^SI^SI}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_592(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct pyobjcanonymous0 objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{pyobjcanonymous0=^SI^SI^SI}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSAffineTransformStruct=ffffff}12 */
struct _NSAffineTransformStruct {
	float field_0;
	float field_1;
	float field_2;
	float field_3;
	float field_4;
	float field_5;
};

static void 
meth_imp_593(id self, SEL sel, struct _NSAffineTransformStruct arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSAffineTransformStruct=ffffff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_593(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSAffineTransformStruct objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSAffineTransformStruct=ffffff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12 */
static void 
meth_imp_594(id self, SEL sel, struct _NSPoint arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_594(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12@20 */
static void 
meth_imp_595(id self, SEL sel, struct _NSPoint arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_595(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12d40 */
static void 
meth_imp_596(id self, SEL sel, struct _NSPoint arg_2, double arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_596(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	double objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12d40d48d56 */
static void 
meth_imp_597(id self, SEL sel, struct _NSPoint arg_2, double arg_3, double arg_4, double arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("d", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_597(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	double objc_arg3;
	double objc_arg4;
	double objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("d", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12f40 */
static void 
meth_imp_598(id self, SEL sel, struct _NSPoint arg_2, float arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_598(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	float objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12f40f48f56 */
static void 
meth_imp_599(id self, SEL sel, struct _NSPoint arg_2, float arg_3, float arg_4, float arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_599(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	float objc_arg3;
	float objc_arg4;
	float objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12f40f48f56c32 */
static void 
meth_imp_600(id self, SEL sel, struct _NSPoint arg_2, float arg_3, float arg_4, float arg_5, char arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_600(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	float objc_arg3;
	float objc_arg4;
	float objc_arg5;
	char objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12i20 */
static void 
meth_imp_601(id self, SEL sel, struct _NSPoint arg_2, int arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_601(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	int objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12i20f40 */
static void 
meth_imp_602(id self, SEL sel, struct _NSPoint arg_2, int arg_3, float arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_602(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	int objc_arg3;
	float objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12{_NSPoint=ff}20 */
static void 
meth_imp_603(id self, SEL sel, struct _NSPoint arg_2, struct _NSPoint arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_603(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	struct _NSPoint objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12{_NSPoint=ff}20@28 */
static void 
meth_imp_604(id self, SEL sel, struct _NSPoint arg_2, struct _NSPoint arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_604(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	struct _NSPoint objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12{_NSPoint=ff}20@28c32 */
static void 
meth_imp_605(id self, SEL sel, struct _NSPoint arg_2, struct _NSPoint arg_3, id arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_605(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	struct _NSPoint objc_arg3;
	id objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12{_NSPoint=ff}20f40 */
static void 
meth_imp_606(id self, SEL sel, struct _NSPoint arg_2, struct _NSPoint arg_3, float arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_606(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	struct _NSPoint objc_arg3;
	float objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12{_NSPoint=ff}20{_NSPoint=ff}28 */
static void 
meth_imp_607(id self, SEL sel, struct _NSPoint arg_2, struct _NSPoint arg_3, struct _NSPoint arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_607(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	struct _NSPoint objc_arg3;
	struct _NSPoint objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12{_NSRange=II}20 */
static void 
meth_imp_608(id self, SEL sel, struct _NSPoint arg_2, struct _NSRange arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_608(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	struct _NSRange objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12{_NSRange=II}20c28 */
static void 
meth_imp_609(id self, SEL sel, struct _NSPoint arg_2, struct _NSRange arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_609(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	struct _NSRange objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSPoint=ff}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}20f40 */
static void 
meth_imp_610(id self, SEL sel, struct _NSPoint arg_2, struct _NSRect arg_3, float arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_610(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	struct _NSRect objc_arg3;
	float objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSRange=II}12 */
static void 
meth_imp_611(id self, SEL sel, struct _NSRange arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_611(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRange objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSRange=II}12@20 */
static void 
meth_imp_612(id self, SEL sel, struct _NSRange arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_612(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRange objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSRange=II}12@20I24 */
static void 
meth_imp_613(id self, SEL sel, struct _NSRange arg_2, id arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_613(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRange objc_arg2;
	id objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSRange=II}12@20{_NSRange=II}24 */
static void 
meth_imp_614(id self, SEL sel, struct _NSRange arg_2, id arg_3, struct _NSRange arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_614(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRange objc_arg2;
	id objc_arg3;
	struct _NSRange objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8{_NSRange=II}12^@20I24
// Skipped complex signature: v0@4:8{_NSRange=II}12^v20c24
/* signature: v0@4:8{_NSRange=II}12c20 */
static void 
meth_imp_615(id self, SEL sel, struct _NSRange arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_615(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRange objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8{_NSRange=II}12c20^{_NSRange=II}24
// Skipped complex signature: v0@4:8{_NSRange=II}12i20^{_NSRange=II}24
/* signature: v0@4:8{_NSRange=II}12i20c24 */
static void 
meth_imp_616(id self, SEL sel, struct _NSRange arg_2, int arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_616(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRange objc_arg2;
	int objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSRange=II}12r*20I24 */
static void 
meth_imp_617(id self, SEL sel, struct _NSRange arg_2, char* arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("*", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_617(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRange objc_arg2;
	char* objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("*", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSRange=II}12r^S20I24 */
static void 
meth_imp_618(id self, SEL sel, struct _NSRange arg_2, unsigned short  *arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("S", arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_618(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRange objc_arg2;
	unsigned short objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("S", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8{_NSRange=II}12r^v20
// Skipped complex signature: v0@4:8{_NSRange=II}12r^v20I24
/* signature: v0@4:8{_NSRange=II}12{_NSRange=II}20 */
static void 
meth_imp_619(id self, SEL sel, struct _NSRange arg_2, struct _NSRange arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_619(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRange objc_arg2;
	struct _NSRange objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8{_NSRange=II}12{_NSRange=II}20i28^{_NSRange=II}32
/* signature: v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12 */
static void 
meth_imp_620(id self, SEL sel, struct _NSRect arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_620(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28 */
static void 
meth_imp_621(id self, SEL sel, struct _NSRect arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_621(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28@32 */
static void 
meth_imp_622(id self, SEL sel, struct _NSRect arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_622(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28I32 */
static void 
meth_imp_623(id self, SEL sel, struct _NSRect arg_2, id arg_3, unsigned int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_623(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	id objc_arg3;
	unsigned int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28c32 */
static void 
meth_imp_624(id self, SEL sel, struct _NSRect arg_2, id arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_624(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	id objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28i32 */
static void 
meth_imp_625(id self, SEL sel, struct _NSRect arg_2, id arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_625(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	id objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12c28 */
static void 
meth_imp_626(id self, SEL sel, struct _NSRect arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_626(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12c28@32 */
static void 
meth_imp_627(id self, SEL sel, struct _NSRect arg_2, char arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_627(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	char objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12c28c32 */
static void 
meth_imp_628(id self, SEL sel, struct _NSRect arg_2, char arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_628(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	char objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12f40 */
static void 
meth_imp_629(id self, SEL sel, struct _NSRect arg_2, float arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_629(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	float objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSSize=ff}28 */
static void 
meth_imp_630(id self, SEL sel, struct _NSRect arg_2, struct _NSSize arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_630(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	struct _NSSize objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSSize=ff}12 */
static void 
meth_imp_631(id self, SEL sel, struct _NSSize arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_631(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSSize objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v0@4:8{_NSSize=ff}12^{_NSSize=ff}20^{_NSRect={_NSPoint=ff}{_NSSize=ff}}24^{_NSRect={_NSPoint=ff}{_NSSize=ff}}28
/* signature: v0@4:8{_NSSize=ff}12c20 */
static void 
meth_imp_632(id self, SEL sel, struct _NSSize arg_2, char arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_632(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSSize objc_arg2;
	char objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSSize=ff}12c20c24 */
static void 
meth_imp_633(id self, SEL sel, struct _NSSize arg_2, char arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_633(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSSize objc_arg2;
	char objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSSize=ff}12c20{_NSSize=ff}24c32 */
static void 
meth_imp_634(id self, SEL sel, struct _NSSize arg_2, char arg_3, struct _NSSize arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_634(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSSize objc_arg2;
	char objc_arg3;
	struct _NSSize objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v0@4:8{_NSSize=ff}12{_NSRange=II}20 */
static void 
meth_imp_635(id self, SEL sel, struct _NSSize arg_2, struct _NSRange arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_635(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSSize objc_arg2;
	struct _NSRange objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v104@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}24{_NSRect={_NSPoint=ff}{_NSSize=ff}}40{_NSRect={_NSPoint=ff}{_NSSize=ff}}56{_NSRect={_NSPoint=ff}{_NSSize=ff}}72{_NSRect={_NSPoint=ff}{_NSSize=ff}}88 */
static void 
meth_imp_636(id self, SEL sel, struct _NSRect arg_2, struct _NSRect arg_3, struct _NSRect arg_4, struct _NSRect arg_5, struct _NSRect arg_6, struct _NSRect arg_7)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(7);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_636(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	struct _NSRect objc_arg3;
	struct _NSRect objc_arg4;
	struct _NSRect objc_arg5;
	struct _NSRect objc_arg6;
	struct _NSRect objc_arg7;
	struct objc_super super;

	if (PyTuple_Size(args) != 6) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v36@4:8@12@16@20@24@28:32^v32
/* signature: v36@4:8@12@16@20@24@28@32c35 */
static void 
meth_imp_637(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5, id arg_6, id arg_7, char arg_8)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(8);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_637(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	id objc_arg7;
	char objc_arg8;
	struct objc_super super;

	if (PyTuple_Size(args) != 7) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v36@4:8@12@16i20@24@28^i32c35
/* signature: v36@4:8@12I16{_NSRange=II}20i28{_NSRange=II}28 */
static void 
meth_imp_638(id self, SEL sel, id arg_2, unsigned int arg_3, struct _NSRange arg_4, int arg_5, struct _NSRange arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_638(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	unsigned int objc_arg3;
	struct _NSRange objc_arg4;
	int objc_arg5;
	struct _NSRange objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v36@4:8@12^@16^c20^@24^@28^:32^I32
/* signature: v36@4:8@12{_NSPoint=ff}16f40@28i32@32 */
static void 
meth_imp_639(id self, SEL sel, id arg_2, struct _NSPoint arg_3, float arg_4, id arg_5, int arg_6, id arg_7)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(7);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_639(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSPoint objc_arg3;
	float objc_arg4;
	id objc_arg5;
	int objc_arg6;
	id objc_arg7;
	struct objc_super super;

	if (PyTuple_Size(args) != 6) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v36@4:8@12{_NSRange=II}16I24I28^{_NSRange=II}32^I32
/* signature: v36@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32c35 */
static void 
meth_imp_640(id self, SEL sel, id arg_2, struct _NSRect arg_3, id arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_640(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSRect objc_arg3;
	id objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v36@4:8^i12^i16^i20^i24^i28^i32@32
// Skipped complex signature: v36@4:8c12c16c20c24@28:32^v32
/* signature: v36@4:8c12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32@32 */
static void 
meth_imp_641(id self, SEL sel, char arg_2, struct _NSRect arg_3, id arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_641(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_arg2;
	struct _NSRect objc_arg3;
	id objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v36@4:8i12i16i20{_NSRect={_NSPoint=ff}{_NSSize=ff}}20 */
static void 
meth_imp_642(id self, SEL sel, int arg_2, int arg_3, int arg_4, struct _NSRect arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_642(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	int objc_arg3;
	int objc_arg4;
	struct _NSRect objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v36@4:8{_NSPoint=ff}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}20i32 */
static void 
meth_imp_643(id self, SEL sel, struct _NSPoint arg_2, struct _NSRect arg_3, int arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_643(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	struct _NSRect objc_arg3;
	int objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v36@4:8{_NSPoint=ff}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}20i32f40 */
static void 
meth_imp_644(id self, SEL sel, struct _NSPoint arg_2, struct _NSRect arg_3, int arg_4, float arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_644(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	struct _NSRect objc_arg3;
	int objc_arg4;
	float objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28@32@32 */
static void 
meth_imp_645(id self, SEL sel, struct _NSRect arg_2, id arg_3, id arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_645(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28I32@32 */
static void 
meth_imp_646(id self, SEL sel, struct _NSRect arg_2, id arg_3, unsigned int arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_646(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	id objc_arg3;
	unsigned int objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28c32i32 */
static void 
meth_imp_647(id self, SEL sel, struct _NSRect arg_2, id arg_3, char arg_4, int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_647(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	id objc_arg3;
	char objc_arg4;
	int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28i32i32 */
static void 
meth_imp_648(id self, SEL sel, struct _NSRect arg_2, id arg_3, int arg_4, int arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_648(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	id objc_arg3;
	int objc_arg4;
	int objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12I28i32c35 */
static void 
meth_imp_649(id self, SEL sel, struct _NSRect arg_2, unsigned int arg_3, int arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_649(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	unsigned int objc_arg3;
	int objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12c28@32c35 */
static void 
meth_imp_650(id self, SEL sel, struct _NSRect arg_2, char arg_3, id arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_650(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	char objc_arg3;
	id objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v40@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32I32@36 */
static void 
meth_imp_651(id self, SEL sel, id arg_2, struct _NSRect arg_3, id arg_4, unsigned int arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("I", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_651(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSRect objc_arg3;
	id objc_arg4;
	unsigned int objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("I", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v40@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16c32@32c39 */
static void 
meth_imp_652(id self, SEL sel, id arg_2, struct _NSRect arg_3, char arg_4, id arg_5, char arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_652(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSRect objc_arg3;
	char objc_arg4;
	id objc_arg5;
	char objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v40@4:8{_NSPoint=ff}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}20c35c39 */
static void 
meth_imp_653(id self, SEL sel, struct _NSPoint arg_2, struct _NSRect arg_3, char arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_653(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSPoint objc_arg2;
	struct _NSRect objc_arg3;
	char objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v40@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28@32@32@36 */
static void 
meth_imp_654(id self, SEL sel, struct _NSRect arg_2, id arg_3, id arg_4, id arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_654(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v40@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}24 */
static void 
meth_imp_655(id self, SEL sel, struct _NSRect arg_2, struct _NSRect arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_655(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	struct _NSRect objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v44@4:8@12{_NSPoint=ff}16{_NSSize=ff}24@32@32@36c43 */
static void 
meth_imp_656(id self, SEL sel, id arg_2, struct _NSPoint arg_3, struct _NSSize arg_4, id arg_5, id arg_6, id arg_7, char arg_8)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(8);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_656(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSPoint objc_arg3;
	struct _NSSize objc_arg4;
	id objc_arg5;
	id objc_arg6;
	id objc_arg7;
	char objc_arg8;
	struct objc_super super;

	if (PyTuple_Size(args) != 7) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v44@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16{_NSRect={_NSPoint=ff}{_NSSize=ff}}28 */
static void 
meth_imp_657(id self, SEL sel, id arg_2, struct _NSRect arg_3, struct _NSRect arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_657(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct _NSRect objc_arg3;
	struct _NSRect objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v44@4:8f40{_NSPoint=ff}16{_NSPoint=ff}24{_NSPoint=ff}28{_NSPoint=ff}36 */
static void 
meth_imp_658(id self, SEL sel, float arg_2, struct _NSPoint arg_3, struct _NSPoint arg_4, struct _NSPoint arg_5, struct _NSPoint arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_658(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	float objc_arg2;
	struct _NSPoint objc_arg3;
	struct _NSPoint objc_arg4;
	struct _NSPoint objc_arg5;
	struct _NSPoint objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v44@4:8i12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16{_NSRect={_NSPoint=ff}{_NSSize=ff}}28 */
static void 
meth_imp_659(id self, SEL sel, int arg_2, struct _NSRect arg_3, struct _NSRect arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_659(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	struct _NSRect objc_arg3;
	struct _NSRect objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v44@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28@32@32i36i40 */
static void 
meth_imp_660(id self, SEL sel, struct _NSRect arg_2, id arg_3, id arg_4, id arg_5, int arg_6, int arg_7)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(7);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_660(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	int objc_arg6;
	int objc_arg7;
	struct objc_super super;

	if (PyTuple_Size(args) != 6) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v44@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}24@40 */
static void 
meth_imp_661(id self, SEL sel, struct _NSRect arg_2, struct _NSRect arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_661(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	struct _NSRect objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v44@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}24c43 */
static void 
meth_imp_662(id self, SEL sel, struct _NSRect arg_2, struct _NSRect arg_3, char arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_662(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	struct _NSRect objc_arg3;
	char objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v44@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}24i40f40 */
static void 
meth_imp_663(id self, SEL sel, struct _NSRect arg_2, struct _NSRect arg_3, int arg_4, float arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_663(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	struct _NSRect objc_arg3;
	int objc_arg4;
	float objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v48@4:8@12@16{_NSPoint=ff}20{_NSSize=ff}28@32@36@40c47 */
static void 
meth_imp_664(id self, SEL sel, id arg_2, id arg_3, struct _NSPoint arg_4, struct _NSSize arg_5, id arg_6, id arg_7, id arg_8, char arg_9)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(9);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("{_NSSize=ff}", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_9);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 8, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_664(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	struct _NSPoint objc_arg4;
	struct _NSSize objc_arg5;
	id objc_arg6;
	id objc_arg7;
	id objc_arg8;
	char objc_arg9;
	struct objc_super super;

	if (PyTuple_Size(args) != 8) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("{_NSSize=ff}", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 7);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg9);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8, objc_arg9);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v48@4:8@12@16{_NSRect={_NSPoint=ff}{_NSSize=ff}}20{_NSRect={_NSPoint=ff}{_NSSize=ff}}32f40 */
static void 
meth_imp_665(id self, SEL sel, id arg_2, id arg_3, struct _NSRect arg_4, struct _NSRect arg_5, float arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("f", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_665(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	struct _NSRect objc_arg4;
	struct _NSRect objc_arg5;
	float objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("f", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v48@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRange=II}28{_NSRect={_NSPoint=ff}{_NSSize=ff}}32 */
static void 
meth_imp_666(id self, SEL sel, struct _NSRect arg_2, struct _NSRange arg_3, struct _NSRect arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_666(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	struct _NSRange objc_arg3;
	struct _NSRect objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v48@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}24c43c47 */
static void 
meth_imp_667(id self, SEL sel, struct _NSRect arg_2, struct _NSRect arg_3, char arg_4, char arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_667(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRect objc_arg2;
	struct _NSRect objc_arg3;
	char objc_arg4;
	char objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v52@4:8i12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16{_NSRect={_NSPoint=ff}{_NSSize=ff}}28c47i48 */
static void 
meth_imp_668(id self, SEL sel, int arg_2, struct _NSRect arg_3, struct _NSRect arg_4, char arg_5, int arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("i", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_668(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	int objc_arg2;
	struct _NSRect objc_arg3;
	struct _NSRect objc_arg4;
	char objc_arg5;
	int objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("i", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v52@4:8{_NSRange=II}12r^{ATSGlyphVector=III^v*I^v^{ATSStyleSetting}SsiiI{FixedRect=iiii}IiiiSS^S^s^s^i^i}20{_NSPoint=ff}24c32{_NSRect={_NSPoint=ff}{_NSSize=ff}}32c51 */
struct ATSStyleSetting;struct FixedRect {
	int field_0;
	int field_1;
	int field_2;
	int field_3;
};
struct ATSGlyphVector {
	unsigned int field_0;
	unsigned int field_1;
	unsigned int field_2;
	void  *field_3;
	char* field_4;
	unsigned int field_5;
	void  *field_6;
	struct ATSStyleSetting  *field_7;
	unsigned short field_8;
	short field_9;
	int field_10;
	int field_11;
	unsigned int field_12;
	struct FixedRect field_13;
	unsigned int field_14;
	int field_15;
	int field_16;
	int field_17;
	unsigned short field_18;
	unsigned short field_19;
	unsigned short  *field_20;
	short  *field_21;
	short  *field_22;
	int  *field_23;
	int  *field_24;
};

static void 
meth_imp_669(id self, SEL sel, struct _NSRange arg_2, struct ATSGlyphVector  *arg_3, struct _NSPoint arg_4, char arg_5, struct _NSRect arg_6, char arg_7)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(7);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("{_NSRange=II}", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("{ATSGlyphVector=III^v*I^v^{ATSStyleSetting=}SsiiI{FixedRect=iiii}IiiiSS^S^s^s^i^i}", arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("{_NSPoint=ff}", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("c", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_669(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	struct _NSRange objc_arg2;
	struct ATSGlyphVector objc_arg3;
	struct _NSPoint objc_arg4;
	char objc_arg5;
	struct _NSRect objc_arg6;
	char objc_arg7;
	struct objc_super super;

	if (PyTuple_Size(args) != 6) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("{_NSRange=II}", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("{ATSGlyphVector=III^v*I^v^{ATSStyleSetting=}SsiiI{FixedRect=iiii}IiiiSS^S^s^s^i^i}", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("{_NSPoint=ff}", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("{_NSRect={_NSPoint=ff}{_NSSize=ff}}", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("c", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


// Skipped complex signature: v52@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28^{_NSRect={_NSPoint=ff}{_NSSize=ff}}32^{_NSRect={_NSPoint=ff}{_NSSize=ff}}32^{_NSRect={_NSPoint=ff}{_NSSize=ff}}36^{_NSRect={_NSPoint=ff}{_NSSize=ff}}40^{_NSRect={_NSPoint=ff}{_NSSize=ff}}44^{_NSRect={_NSPoint=ff}{_NSSize=ff}}48
/* signature: v@: */
static void 
meth_imp_670(id self, SEL sel)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(1);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_670(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	struct objc_super super;

	if (PyTuple_Size(args) != 0) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth));
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v@:@ */
static void 
meth_imp_671(id self, SEL sel, id arg_2)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_671(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v@:@@ */
static void 
meth_imp_672(id self, SEL sel, id arg_2, id arg_3)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_672(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v@:@@@ */
static void 
meth_imp_673(id self, SEL sel, id arg_2, id arg_3, id arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(4);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_673(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 3) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v@:@@@@ */
static void 
meth_imp_674(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(5);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_674(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	struct objc_super super;

	if (PyTuple_Size(args) != 4) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v@:@@@@@ */
static void 
meth_imp_675(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5, id arg_6)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(6);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_675(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	struct objc_super super;

	if (PyTuple_Size(args) != 5) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v@:@@@@@@ */
static void 
meth_imp_676(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5, id arg_6, id arg_7)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(7);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_676(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	id objc_arg7;
	struct objc_super super;

	if (PyTuple_Size(args) != 6) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: v@:@@@@@@@ */
static void 
meth_imp_677(id self, SEL sel, id arg_2, id arg_3, id arg_4, id arg_5, id arg_6, id arg_7, id arg_8)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(8);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_4);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 3, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_5);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 4, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_6);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 5, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_7);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 6, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_8);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 7, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	Py_DECREF(retval);
}
static PyObject* super_677(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	id objc_arg5;
	id objc_arg6;
	id objc_arg7;
	id objc_arg8;
	struct objc_super super;

	if (PyTuple_Size(args) != 7) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 2);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg4);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 3);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg5);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 4);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg6);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 5);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg7);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 6);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg8);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4, objc_arg5, objc_arg6, objc_arg7, objc_arg8);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}


/* signature: c@:o^@@o^@ */
static char 
meth_imp_678(id self, SEL sel, id  *arg_2, id arg_3, id  *arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;
	const char* errstr;
	char objc_retval;

	arglist = PyTuple_New(2);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 3) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		v = PySequence_GetItem(retval, 0);
		errstr = ObjC_PythonToObjC("c", v, &objc_retval);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("@", v, arg_2);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		v = PySequence_GetItem(retval, 2);
		errstr = ObjC_PythonToObjC("@", v, arg_4);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
	return objc_retval;
}
static PyObject* super_678(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	char objc_retval;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 1) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		objc_retval = (char)(long)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(3);
		if (result_list == NULL) return NULL;

		v = ObjC_ObjCToPython("c", &objc_retval);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }
		PyTuple_SET_ITEM(result_list, 0, v);
		v = ObjC_ObjCToPython("@", &objc_arg2);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		v = ObjC_ObjCToPython("@", &objc_arg4);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 2, v);
		return result_list;
	}
}


/* signature: v@:@@o^@ */
static void 
meth_imp_679(id self, SEL sel, id arg_2, id arg_3, id  *arg_4)
{
	PyObject* arglist;
	PyObject* retval;
	PyObject* tmp;

	arglist = PyTuple_New(3);
	if (arglist == NULL) ObjCErr_ToObjC();

	tmp = ObjC_ObjCToPython("@", &self);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 0, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_2);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 1, tmp);
	tmp = ObjC_ObjCToPython("@", &arg_3);
	if (tmp == NULL) ObjCErr_ToObjC();
	PyTuple_SET_ITEM(arglist, 2, tmp);

	retval = ObjC_CallPython(self, sel, arglist);
	Py_DECREF(arglist);
	if (retval == NULL) ObjCErr_ToObjC();
	if (!PySequence_Check(retval)) {
		PyErr_SetString(PyExc_ValueError, "result is not a tuple");

		ObjCErr_ToObjC();
	}
	if (PySequence_Length(retval) != 2) {
		PyErr_SetString(PyExc_ValueError, "Wrong number of results");

		ObjCErr_ToObjC();
	}
	{
		PyObject* v;
		const char* errstr;

		v = PySequence_GetItem(retval, 1);
		errstr = ObjC_PythonToObjC("@", v, arg_4);
		Py_DECREF(v);
		if (errstr != NULL) {
			PyErr_SetString(PyExc_ValueError, "Cannot convert to ObjC");
			ObjCErr_ToObjC();
		}
		Py_DECREF(retval);
	}
}
static PyObject* super_679(PyObject* meth, PyObject* self, PyObject* args)
{
	id objc_self;
	const char* errstr;
	PyObject* v;
	id objc_arg2;
	id objc_arg3;
	id objc_arg4;
	struct objc_super super;

	if (PyTuple_Size(args) != 2) {
		PyErr_SetString(PyExc_TypeError, "Wrong argcount");
		return NULL;
	}
	errstr = ObjC_PythonToObjC("@", self, &objc_self);
	if (errstr != NULL) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert self");
		return NULL;
	} 	RECEIVER(super) = objc_self;
	super.class = ObjCSelector_GetClass(meth);
	v = PyTuple_GET_ITEM(args, 0);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg2);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	v = PyTuple_GET_ITEM(args, 1);
	errstr = ObjC_PythonToObjC("@", v, &objc_arg3);
	if (errstr) {
		PyErr_SetString(PyExc_TypeError, "Cannot convert argument");
	return NULL;
	}
	NS_DURING
		(void)objc_msgSendSuper(&super, ObjCSelector_GetSelector(meth), objc_arg2, objc_arg3, objc_arg4);
	NS_HANDLER
		ObjCErr_FromObjC(localException);
	NS_ENDHANDLER
	if (PyErr_Occurred()) return NULL;
	{
		PyObject* result_list;

		result_list = PyTuple_New(2);
		if (result_list == NULL) return NULL;

		Py_INCREF(Py_None);
		PyTuple_SET_ITEM(result_list, 0, Py_None);
		v = ObjC_ObjCToPython("@", &objc_arg4);
		if (v == NULL) { Py_DECREF(result_list); return NULL; }

		PyTuple_SET_ITEM(result_list, 1, v);
		return result_list;
	}
}


static struct method_table {
	char* signature;
	superfunc call_super;
	IMP implementation;
} method_table[] = {
	{ "c@:@@", (superfunc)super_0, (IMP)meth_imp_0 },
	{ "@@:@i@", (superfunc)super_1, (IMP)meth_imp_1 },
	{ "i@:@@", (superfunc)super_2, (IMP)meth_imp_2 },
	{ "#0@4:8", (superfunc)super_3, (IMP)meth_imp_3 },
	{ "#0@4:8@12", (superfunc)super_4, (IMP)meth_imp_4 },
	{ "#0@4:8@12@16", (superfunc)super_5, (IMP)meth_imp_5 },
	{ "#0@4:8I12", (superfunc)super_6, (IMP)meth_imp_6 },
	{ "*0@4:8", (superfunc)super_7, (IMP)meth_imp_7 },
#ifndef GNU_RUNTIME
	{ "8@12o^@16", (superfunc)super_8, (IMP)meth_imp_8 },
#endif
	{ ":0@4:8", (superfunc)super_9, (IMP)meth_imp_9 },
	{ ":0@4:8@12", (superfunc)super_10, (IMP)meth_imp_10 },
	{ "@0@4:8", (superfunc)super_11, (IMP)meth_imp_11 },
	{ "@0@4:8#12", (superfunc)super_12, (IMP)meth_imp_12 },
	{ "@0@4:8#12@16@20:24", (superfunc)super_13, (IMP)meth_imp_13 },
	{ "@0@4:8*12", (superfunc)super_14, (IMP)meth_imp_14 },
	{ "@0@4:8*12*16", (superfunc)super_15, (IMP)meth_imp_15 },
	{ "@0@4:8*12*16*20*24*28c32", (superfunc)super_16, (IMP)meth_imp_16 },
	{ "@0@4:8*12@16*20", (superfunc)super_17, (IMP)meth_imp_17 },
	{ "@0@4:8*12I16", (superfunc)super_18, (IMP)meth_imp_18 },
	{ "@0@4:8*12I16c20", (superfunc)super_19, (IMP)meth_imp_19 },
	{ "@0@4:8*12i16", (superfunc)super_20, (IMP)meth_imp_20 },
	{ "@0@4:8:12", (superfunc)super_21, (IMP)meth_imp_21 },
	{ "@0@4:8:12@16", (superfunc)super_22, (IMP)meth_imp_22 },
	{ "@0@4:8:12@16@20", (superfunc)super_23, (IMP)meth_imp_23 },
	{ "@0@4:8:12c16", (superfunc)super_24, (IMP)meth_imp_24 },
	{ "@0@4:8:12i16@20@24", (superfunc)super_25, (IMP)meth_imp_25 },
	{ "@0@4:8:12{_NSRange=II}16@24", (superfunc)super_26, (IMP)meth_imp_26 },
	{ "@0@4:8@12", (superfunc)super_27, (IMP)meth_imp_27 },
	{ "@0@4:8@12#16", (superfunc)super_28, (IMP)meth_imp_28 },
	{ "@0@4:8@12*16", (superfunc)super_29, (IMP)meth_imp_29 },
	{ "@0@4:8@12:16", (superfunc)super_30, (IMP)meth_imp_30 },
	{ "@0@4:8@12:16@20", (superfunc)super_31, (IMP)meth_imp_31 },
	{ "@0@4:8@12:16@20i24", (superfunc)super_32, (IMP)meth_imp_32 },
	{ "@0@4:8@12:16i20", (superfunc)super_33, (IMP)meth_imp_33 },
	{ "@0@4:8@12@16", (superfunc)super_34, (IMP)meth_imp_34 },
	{ "@0@4:8@12@16*20", (superfunc)super_35, (IMP)meth_imp_35 },
	{ "@0@4:8@12@16:20@24", (superfunc)super_36, (IMP)meth_imp_36 },
	{ "@0@4:8@12@16@20", (superfunc)super_37, (IMP)meth_imp_37 },
	{ "@0@4:8@12@16@20@24", (superfunc)super_38, (IMP)meth_imp_38 },
	{ "@0@4:8@12@16@20@24@28", (superfunc)super_39, (IMP)meth_imp_39 },
	{ "@0@4:8@12@16@20@24@28@32", (superfunc)super_40, (IMP)meth_imp_40 },
	{ "@0@4:8@12@16@20@24c28", (superfunc)super_41, (IMP)meth_imp_41 },
	{ "@0@4:8@12@16@20@24c28i32", (superfunc)super_42, (IMP)meth_imp_42 },
	{ "@0@4:8@12@16@20@24i28", (superfunc)super_43, (IMP)meth_imp_43 },
	{ "@0@4:8@12@16@20c24", (superfunc)super_44, (IMP)meth_imp_44 },
	{ "@0@4:8@12@16@20c24@28", (superfunc)super_45, (IMP)meth_imp_45 },
	{ "@0@4:8@12@16@20i24", (superfunc)super_46, (IMP)meth_imp_46 },
	{ "@0@4:8@12@16@20i24@28", (superfunc)super_47, (IMP)meth_imp_47 },
	{ "@0@4:8@12@16@20{_NSPoint=ff}24", (superfunc)super_48, (IMP)meth_imp_48 },
	{ "@0@4:8@12@16I20", (superfunc)super_49, (IMP)meth_imp_49 },
	{ "@0@4:8@12@16I20@24", (superfunc)super_50, (IMP)meth_imp_50 },
	{ "@0@4:8@12@16I20@24@28", (superfunc)super_51, (IMP)meth_imp_51 },
	{ "@0@4:8@12@16S20", (superfunc)super_52, (IMP)meth_imp_52 },
	{ "@0@4:8@12@16c20", (superfunc)super_53, (IMP)meth_imp_53 },
	{ "@0@4:8@12@16c20@24", (superfunc)super_54, (IMP)meth_imp_54 },
	{ "@0@4:8@12@16f40", (superfunc)super_55, (IMP)meth_imp_55 },
	{ "@0@4:8@12@16i20", (superfunc)super_56, (IMP)meth_imp_56 },
	{ "@0@4:8@12@16i20c24", (superfunc)super_57, (IMP)meth_imp_57 },
	{ "@0@4:8@12@16i20i24", (superfunc)super_58, (IMP)meth_imp_58 },
	{ "@0@4:8@12@16o^@20", (superfunc)super_59, (IMP)meth_imp_59 },
	{ "@0@4:8@12@16{_NSRange=II}20@28", (superfunc)super_60, (IMP)meth_imp_60 },
	{ "@0@4:8@12I16", (superfunc)super_61, (IMP)meth_imp_61 },
	{ "@0@4:8@12I16@20", (superfunc)super_62, (IMP)meth_imp_62 },
	{ "@0@4:8@12I16@20@24", (superfunc)super_63, (IMP)meth_imp_63 },
	{ "@0@4:8@12I16I20", (superfunc)super_64, (IMP)meth_imp_64 },
	{ "@0@4:8@12I16i20", (superfunc)super_65, (IMP)meth_imp_65 },
	{ "@0@4:8@12I16i20f40", (superfunc)super_66, (IMP)meth_imp_66 },
	{ "@0@4:8@12I16o^{_NSRange=II}20", (superfunc)super_67, (IMP)meth_imp_67 },
	{ "@0@4:8@12I16o^{_NSRange=II}20{_NSRange=II}24", (superfunc)super_68, (IMP)meth_imp_68 },
	{ "@0@4:8@12L16", (superfunc)super_69, (IMP)meth_imp_69 },
	{ "@0@4:8@12c16", (superfunc)super_70, (IMP)meth_imp_70 },
	{ "@0@4:8@12c16c20", (superfunc)super_71, (IMP)meth_imp_71 },
	{ "@0@4:8@12f40", (superfunc)super_72, (IMP)meth_imp_72 },
	{ "@0@4:8@12f40@20{_NSPoint=ff}24", (superfunc)super_73, (IMP)meth_imp_73 },
	{ "@0@4:8@12f40r^f20", (superfunc)super_74, (IMP)meth_imp_74 },
	{ "@0@4:8@12f40r^f20I24", (superfunc)super_75, (IMP)meth_imp_75 },
	{ "@0@4:8@12f40r^f20i24", (superfunc)super_76, (IMP)meth_imp_76 },
	{ "@0@4:8@12i16", (superfunc)super_77, (IMP)meth_imp_77 },
	{ "@0@4:8@12i16:20", (superfunc)super_78, (IMP)meth_imp_78 },
	{ "@0@4:8@12i16@20", (superfunc)super_79, (IMP)meth_imp_79 },
	{ "@0@4:8@12i16I20", (superfunc)super_80, (IMP)meth_imp_80 },
	{ "@0@4:8@12i16f40", (superfunc)super_81, (IMP)meth_imp_81 },
	{ "@0@4:8@12i16i20", (superfunc)super_82, (IMP)meth_imp_82 },
	{ "@0@4:8@12i16i20@24", (superfunc)super_83, (IMP)meth_imp_83 },
	{ "@0@4:8@12i16{_NSRect={_NSPoint=ff}{_NSSize=ff}}20", (superfunc)super_84, (IMP)meth_imp_84 },
	{ "@0@4:8@12o^@16", (superfunc)super_85, (IMP)meth_imp_85 },
	{ "@0@4:8@12r*16I20", (superfunc)super_86, (IMP)meth_imp_86 },
	{ "@0@4:8@12r^f16", (superfunc)super_87, (IMP)meth_imp_87 },
	{ "@0@4:8@12r^{FSRef=[80C]}16", (superfunc)super_88, (IMP)meth_imp_88 },
	{ "@0@4:8@12{_NSPoint=ff}16", (superfunc)super_89, (IMP)meth_imp_89 },
	{ "@0@4:8@12{_NSRange=II}16", (superfunc)super_90, (IMP)meth_imp_90 },
	{ "@0@4:8@12{_NSRange=II}16i24", (superfunc)super_91, (IMP)meth_imp_91 },
	{ "@0@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16", (superfunc)super_92, (IMP)meth_imp_92 },
	{ "@0@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32", (superfunc)super_93, (IMP)meth_imp_93 },
	{ "@0@4:8C12", (superfunc)super_94, (IMP)meth_imp_94 },
	{ "@0@4:8I12", (superfunc)super_95, (IMP)meth_imp_95 },
	{ "@0@4:8I12:16", (superfunc)super_96, (IMP)meth_imp_96 },
	{ "@0@4:8I12@16", (superfunc)super_97, (IMP)meth_imp_97 },
	{ "@0@4:8I12@16@20", (superfunc)super_98, (IMP)meth_imp_98 },
	{ "@0@4:8I12@16@20c24", (superfunc)super_99, (IMP)meth_imp_99 },
	{ "@0@4:8I12@16@20l24", (superfunc)super_100, (IMP)meth_imp_100 },
	{ "@0@4:8I12@16I20", (superfunc)super_101, (IMP)meth_imp_101 },
	{ "@0@4:8I12I16", (superfunc)super_102, (IMP)meth_imp_102 },
	{ "@0@4:8I12I16@20s24i28", (superfunc)super_103, (IMP)meth_imp_103 },
	{ "@0@4:8I12c16", (superfunc)super_104, (IMP)meth_imp_104 },
	{ "@0@4:8I12i16@20", (superfunc)super_105, (IMP)meth_imp_105 },
	{ "@0@4:8I12o^{_NSRange=II}16", (superfunc)super_106, (IMP)meth_imp_106 },
	{ "@0@4:8I12o^{_NSRange=II}16{_NSRange=II}20", (superfunc)super_107, (IMP)meth_imp_107 },
	{ "@0@4:8I12{_NSPoint=ff}16@24", (superfunc)super_108, (IMP)meth_imp_108 },
	{ "@0@4:8I12{_NSRange=II}16", (superfunc)super_109, (IMP)meth_imp_109 },
	{ "@0@4:8L12", (superfunc)super_110, (IMP)meth_imp_110 },
	{ "@0@4:8L12L16", (superfunc)super_111, (IMP)meth_imp_111 },
	{ "@0@4:8Q12", (superfunc)super_112, (IMP)meth_imp_112 },
	{ "@0@4:8Q12s20c24", (superfunc)super_113, (IMP)meth_imp_113 },
	{ "@0@4:8S12", (superfunc)super_114, (IMP)meth_imp_114 },
	{ "@0@4:8S12@16", (superfunc)super_115, (IMP)meth_imp_115 },
	{ "@0@4:8S12I16@20", (superfunc)super_116, (IMP)meth_imp_116 },
	{ "@0@4:8S12S16", (superfunc)super_117, (IMP)meth_imp_117 },
	{ "@0@4:8S12S16@20", (superfunc)super_118, (IMP)meth_imp_118 },
	{ "@0@4:8S12i16", (superfunc)super_119, (IMP)meth_imp_119 },
	{ "@0@4:8c12", (superfunc)super_120, (IMP)meth_imp_120 },
	{ "@0@4:8c12@16", (superfunc)super_121, (IMP)meth_imp_121 },
	{ "@0@4:8c12c16", (superfunc)super_122, (IMP)meth_imp_122 },
	{ "@0@4:8c12i16", (superfunc)super_123, (IMP)meth_imp_123 },
	{ "@0@4:8c12i16i20c24", (superfunc)super_124, (IMP)meth_imp_124 },
	{ "@0@4:8d40", (superfunc)super_125, (IMP)meth_imp_125 },
	{ "@0@4:8d40@20", (superfunc)super_126, (IMP)meth_imp_126 },
	{ "@0@4:8d40@20:24@28c32", (superfunc)super_127, (IMP)meth_imp_127 },
	{ "@0@4:8d40@20c24", (superfunc)super_128, (IMP)meth_imp_128 },
	{ "@0@4:8f40", (superfunc)super_129, (IMP)meth_imp_129 },
	{ "@0@4:8f40@16", (superfunc)super_130, (IMP)meth_imp_130 },
	{ "@0@4:8f40f48", (superfunc)super_131, (IMP)meth_imp_131 },
	{ "@0@4:8f40f48c20", (superfunc)super_132, (IMP)meth_imp_132 },
	{ "@0@4:8f40f48f56f64", (superfunc)super_133, (IMP)meth_imp_133 },
	{ "@0@4:8f40f48f56f64f72", (superfunc)super_134, (IMP)meth_imp_134 },
	{ "@0@4:8i12", (superfunc)super_135, (IMP)meth_imp_135 },
	{ "@0@4:8i12@16", (superfunc)super_136, (IMP)meth_imp_136 },
	{ "@0@4:8i12@16@20@24i28", (superfunc)super_137, (IMP)meth_imp_137 },
	{ "@0@4:8i12@16i20", (superfunc)super_138, (IMP)meth_imp_138 },
	{ "@0@4:8i12I16", (superfunc)super_139, (IMP)meth_imp_139 },
	{ "@0@4:8i12c16", (superfunc)super_140, (IMP)meth_imp_140 },
	{ "@0@4:8i12f40", (superfunc)super_141, (IMP)meth_imp_141 },
	{ "@0@4:8i12f40r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}20r^{_NSPoint=ff}24", (superfunc)super_142, (IMP)meth_imp_142 },
	{ "@0@4:8i12i16", (superfunc)super_143, (IMP)meth_imp_143 },
	{ "@0@4:8i12i16@20", (superfunc)super_144, (IMP)meth_imp_144 },
	{ "@0@4:8i12i16c20", (superfunc)super_145, (IMP)meth_imp_145 },
	{ "@0@4:8i12i16i20", (superfunc)super_146, (IMP)meth_imp_146 },
	{ "@0@4:8i12i16i20@24", (superfunc)super_147, (IMP)meth_imp_147 },
	{ "@0@4:8i12i16i20i24", (superfunc)super_148, (IMP)meth_imp_148 },
	{ "@0@4:8i12i16i20i24i28i32", (superfunc)super_149, (IMP)meth_imp_149 },
	{ "@0@4:8i12r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}16", (superfunc)super_150, (IMP)meth_imp_150 },
	{ "@0@4:8i12r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}16I20", (superfunc)super_151, (IMP)meth_imp_151 },
	{ "@0@4:8i12s16c20c24c28c32", (superfunc)super_152, (IMP)meth_imp_152 },
	{ "@0@4:8i12{_NSRange=II}16", (superfunc)super_153, (IMP)meth_imp_153 },
	{ "@0@4:8i12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16", (superfunc)super_154, (IMP)meth_imp_154 },
	{ "@0@4:8l12", (superfunc)super_155, (IMP)meth_imp_155 },
	{ "@0@4:8q12", (superfunc)super_156, (IMP)meth_imp_156 },
	{ "@0@4:8r*12", (superfunc)super_157, (IMP)meth_imp_157 },
	{ "@0@4:8r*12I16", (superfunc)super_158, (IMP)meth_imp_158 },
	{ "@0@4:8r*12I16I20", (superfunc)super_159, (IMP)meth_imp_159 },
	{ "@0@4:8r^S12I16", (superfunc)super_160, (IMP)meth_imp_160 },
	{ "@0@4:8r^{AEDesc=I^^{OpaqueAEDataStorageType}}12", (superfunc)super_161, (IMP)meth_imp_161 },
	{ "@0@4:8r^{FSRef=[80C]}12", (superfunc)super_162, (IMP)meth_imp_162 },
	{ "@0@4:8r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12", (superfunc)super_163, (IMP)meth_imp_163 },
	{ "@0@4:8r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12I16i20c24@28", (superfunc)super_164, (IMP)meth_imp_164 },
	{ "@0@4:8r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12I16i20c24@28@32", (superfunc)super_165, (IMP)meth_imp_165 },
	{ "@0@4:8r^{_NSSize=ff}12@16", (superfunc)super_166, (IMP)meth_imp_166 },
	{ "@0@4:8s12", (superfunc)super_167, (IMP)meth_imp_167 },
	{ "@0@4:8s12@16", (superfunc)super_168, (IMP)meth_imp_168 },
	{ "@0@4:8{CGPoint=ff}12", (superfunc)super_169, (IMP)meth_imp_169 },
	{ "@0@4:8{NSButtonState=iccc}12", (superfunc)super_170, (IMP)meth_imp_170 },
	{ "@0@4:8{_NSPoint=ff}12", (superfunc)super_171, (IMP)meth_imp_171 },
	{ "@0@4:8{_NSPoint=ff}12c20", (superfunc)super_172, (IMP)meth_imp_172 },
	{ "@0@4:8{_NSRange=II}12", (superfunc)super_173, (IMP)meth_imp_173 },
	{ "@0@4:8{_NSRange=II}12@20", (superfunc)super_174, (IMP)meth_imp_174 },
	{ "@0@4:8{_NSRange=II}12@20@24", (superfunc)super_175, (IMP)meth_imp_175 },
	{ "@0@4:8{_NSRange=II}12@20@24{_NSRange=II}28", (superfunc)super_176, (IMP)meth_imp_176 },
	{ "@0@4:8{_NSRange=II}12c20", (superfunc)super_177, (IMP)meth_imp_177 },
	{ "@0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12", (superfunc)super_178, (IMP)meth_imp_178 },
	{ "@0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28", (superfunc)super_179, (IMP)meth_imp_179 },
	{ "@0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28@32", (superfunc)super_180, (IMP)meth_imp_180 },
	{ "@0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28i32", (superfunc)super_181, (IMP)meth_imp_181 },
	{ "@0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12I28@32", (superfunc)super_182, (IMP)meth_imp_182 },
	{ "@0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12c28", (superfunc)super_183, (IMP)meth_imp_183 },
	{ "@0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12i28", (superfunc)super_184, (IMP)meth_imp_184 },
	{ "@0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12s28", (superfunc)super_185, (IMP)meth_imp_185 },
	{ "@0@4:8{_NSSize=ff}12", (superfunc)super_186, (IMP)meth_imp_186 },
	{ "@0@4:8{_NSSize=ff}12@20", (superfunc)super_187, (IMP)meth_imp_187 },
	{ "@0@4:8{_NSSize=ff}12i20", (superfunc)super_188, (IMP)meth_imp_188 },
	{ "@0@4:8{_NSSize=ff}12i20c24c28", (superfunc)super_189, (IMP)meth_imp_189 },
	{ "@0@4:8{_NSSize=ff}12i20c24c28c32", (superfunc)super_190, (IMP)meth_imp_190 },
	{ "@36@4:8@12:16@20@24@28@32I32", (superfunc)super_191, (IMP)meth_imp_191 },
	{ "@36@4:8@12@16c20@24@28:32I32", (superfunc)super_192, (IMP)meth_imp_192 },
	{ "@36@4:8@12d40@24:28@32c35", (superfunc)super_193, (IMP)meth_imp_193 },
	{ "@36@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32@32", (superfunc)super_194, (IMP)meth_imp_194 },
	{ "@36@4:8@12{_NSSize=ff}16f40f48{_NSPoint=ff}28", (superfunc)super_195, (IMP)meth_imp_195 },
	{ "@36@4:8i12@16@20@24@28@32*32", (superfunc)super_196, (IMP)meth_imp_196 },
	{ "@36@4:8i12I16I20I24I28I32@32", (superfunc)super_197, (IMP)meth_imp_197 },
	{ "@36@4:8r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@16@20@24@28i32i32", (superfunc)super_198, (IMP)meth_imp_198 },
	{ "@36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28I32@32", (superfunc)super_199, (IMP)meth_imp_199 },
	{ "@36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12I28i32c35", (superfunc)super_200, (IMP)meth_imp_200 },
	{ "@40@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12I28i32c35@36", (superfunc)super_201, (IMP)meth_imp_201 },
	{ "@40@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12i28#32i32i36", (superfunc)super_202, (IMP)meth_imp_202 },
	{ "@40@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12i28@32i32i36", (superfunc)super_203, (IMP)meth_imp_203 },
	{ "@48@4:8i12{_NSPoint=ff}16I24d40i32@36i40i44f48", (superfunc)super_204, (IMP)meth_imp_204 },
	{ "@52@4:8i12{_NSPoint=ff}16I24d40i32@36s42i44i48", (superfunc)super_205, (IMP)meth_imp_205 },
	{ "@56@4:8i12{_NSPoint=ff}16I24d40i32@36@40@44c51S54", (superfunc)super_206, (IMP)meth_imp_206 },
	{ "@@:", (superfunc)super_207, (IMP)meth_imp_207 },
	{ "@@:@", (superfunc)super_208, (IMP)meth_imp_208 },
	{ "@@:@@", (superfunc)super_209, (IMP)meth_imp_209 },
	{ "@@:@@@", (superfunc)super_210, (IMP)meth_imp_210 },
	{ "@@:@@@@", (superfunc)super_211, (IMP)meth_imp_211 },
	{ "@@:@@@@@", (superfunc)super_212, (IMP)meth_imp_212 },
	{ "@@:@@@@@@", (superfunc)super_213, (IMP)meth_imp_213 },
	{ "@@:@@@@@@@", (superfunc)super_214, (IMP)meth_imp_214 },
	{ "@@:@@i", (superfunc)super_215, (IMP)meth_imp_215 },
	{ "C0@4:8", (superfunc)super_216, (IMP)meth_imp_216 },
	{ "I0@4:8", (superfunc)super_217, (IMP)meth_imp_217 },
	{ "I0@4:8:12", (superfunc)super_218, (IMP)meth_imp_218 },
	{ "I0@4:8:12@16", (superfunc)super_219, (IMP)meth_imp_219 },
	{ "I0@4:8@12", (superfunc)super_220, (IMP)meth_imp_220 },
	{ "I0@4:8@12@16", (superfunc)super_221, (IMP)meth_imp_221 },
	{ "I0@4:8@12@16@20", (superfunc)super_222, (IMP)meth_imp_222 },
	{ "I0@4:8@12@16I20{_NSRange=II}24", (superfunc)super_223, (IMP)meth_imp_223 },
	{ "I0@4:8@12@16c20", (superfunc)super_224, (IMP)meth_imp_224 },
	{ "I0@4:8@12I16", (superfunc)super_225, (IMP)meth_imp_225 },
	{ "I0@4:8@12I16{_NSRange=II}20@28", (superfunc)super_226, (IMP)meth_imp_226 },
	{ "I0@4:8@12i16@20c24", (superfunc)super_227, (IMP)meth_imp_227 },
	{ "I0@4:8@12{_NSRange=II}16", (superfunc)super_228, (IMP)meth_imp_228 },
	{ "I0@4:8@12{_NSRange=II}16c24", (superfunc)super_229, (IMP)meth_imp_229 },
	{ "I0@4:8I12", (superfunc)super_230, (IMP)meth_imp_230 },
	{ "I0@4:8I12*16", (superfunc)super_231, (IMP)meth_imp_231 },
	{ "I0@4:8I12c16", (superfunc)super_232, (IMP)meth_imp_232 },
	{ "I0@4:8I12{_NSRange=II}16", (superfunc)super_233, (IMP)meth_imp_233 },
	{ "I0@4:8S12", (superfunc)super_234, (IMP)meth_imp_234 },
	{ "I0@4:8c12", (superfunc)super_235, (IMP)meth_imp_235 },
	{ "I0@4:8i12", (superfunc)super_236, (IMP)meth_imp_236 },
	{ "I0@4:8l12", (superfunc)super_237, (IMP)meth_imp_237 },
	{ "I0@4:8{_NSPoint=ff}12", (superfunc)super_238, (IMP)meth_imp_238 },
	{ "I0@4:8{_NSPoint=ff}12@20", (superfunc)super_239, (IMP)meth_imp_239 },
	{ "Io^@co^@@", (superfunc)super_240, (IMP)meth_imp_240 },
	{ "L0@4:8", (superfunc)super_241, (IMP)meth_imp_241 },
	{ "L0@4:8@12", (superfunc)super_242, (IMP)meth_imp_242 },
	{ "O@0@4:8nO@12", (superfunc)super_243, (IMP)meth_imp_243 },
	{ "O@0@4:8nO@12nO@16", (superfunc)super_244, (IMP)meth_imp_244 },
	{ "Q0@4:8", (superfunc)super_245, (IMP)meth_imp_245 },
	{ "S0@4:8", (superfunc)super_246, (IMP)meth_imp_246 },
	{ "S0@4:8I12", (superfunc)super_247, (IMP)meth_imp_247 },
	{ "Vv0@4:8", (superfunc)super_248, (IMP)meth_imp_248 },
	{ "Vv0@4:8@12", (superfunc)super_249, (IMP)meth_imp_249 },
	{ "Vv0@4:8@12i16", (superfunc)super_250, (IMP)meth_imp_250 },
	{ "Vv0@4:8i12c16", (superfunc)super_251, (IMP)meth_imp_251 },
	{ "Vv0@4:8nO@12nO@16", (superfunc)super_252, (IMP)meth_imp_252 },
	{ "Vv0@4:8nO@12ni16", (superfunc)super_253, (IMP)meth_imp_253 },
	{ "c0@4:8", (superfunc)super_254, (IMP)meth_imp_254 },
	{ "c0@4:8#12", (superfunc)super_255, (IMP)meth_imp_255 },
	{ "c0@4:8#12@16", (superfunc)super_256, (IMP)meth_imp_256 },
	{ "c0@4:8*12@16*20@24i28", (superfunc)super_257, (IMP)meth_imp_257 },
	{ "c0@4:8*12I16", (superfunc)super_258, (IMP)meth_imp_258 },
	{ "c0@4:8*12I16@20", (superfunc)super_259, (IMP)meth_imp_259 },
	{ "c0@4:8*12I16I20", (superfunc)super_260, (IMP)meth_imp_260 },
	{ "c0@4:8*12i16c20c24c28", (superfunc)super_261, (IMP)meth_imp_261 },
	{ "c0@4:8:12", (superfunc)super_262, (IMP)meth_imp_262 },
	{ "c0@4:8:12@16", (superfunc)super_263, (IMP)meth_imp_263 },
	{ "c0@4:8:12@16@20", (superfunc)super_264, (IMP)meth_imp_264 },
	{ "c0@4:8:12@16i20i24", (superfunc)super_265, (IMP)meth_imp_265 },
	{ "c0@4:8@12", (superfunc)super_266, (IMP)meth_imp_266 },
	{ "c0@4:8@12:16", (superfunc)super_267, (IMP)meth_imp_267 },
	{ "c0@4:8@12@16", (superfunc)super_268, (IMP)meth_imp_268 },
	{ "c0@4:8@12@16:20", (superfunc)super_269, (IMP)meth_imp_269 },
	{ "c0@4:8@12@16@20", (superfunc)super_270, (IMP)meth_imp_270 },
	{ "c0@4:8@12@16@20I24", (superfunc)super_271, (IMP)meth_imp_271 },
	{ "c0@4:8@12@16@20i24", (superfunc)super_272, (IMP)meth_imp_272 },
	{ "c0@4:8@12@16I20", (superfunc)super_273, (IMP)meth_imp_273 },
	{ "c0@4:8@12@16S20", (superfunc)super_274, (IMP)meth_imp_274 },
	{ "c0@4:8@12@16c20", (superfunc)super_275, (IMP)meth_imp_275 },
	{ "c0@4:8@12@16c20c24", (superfunc)super_276, (IMP)meth_imp_276 },
	{ "c0@4:8@12@16c20c24c28", (superfunc)super_277, (IMP)meth_imp_277 },
	{ "c0@4:8@12@16i20", (superfunc)super_278, (IMP)meth_imp_278 },
	{ "c0@4:8@12@16{_NSPoint=ff}20@28", (superfunc)super_279, (IMP)meth_imp_279 },
	{ "c0@4:8@12I16", (superfunc)super_280, (IMP)meth_imp_280 },
	{ "c0@4:8@12I16@20@24I28", (superfunc)super_281, (IMP)meth_imp_281 },
	{ "c0@4:8@12c16", (superfunc)super_282, (IMP)meth_imp_282 },
	{ "c0@4:8@12c16c20", (superfunc)super_283, (IMP)meth_imp_283 },
	{ "c0@4:8@12i16", (superfunc)super_284, (IMP)meth_imp_284 },
	{ "c0@4:8@12i16@20", (superfunc)super_285, (IMP)meth_imp_285 },
	{ "c0@4:8@12o^c16", (superfunc)super_286, (IMP)meth_imp_286 },
	{ "c0@4:8@12r^{FSRef=[80C]}16r^{FSRef=[80C]}20", (superfunc)super_287, (IMP)meth_imp_287 },
	{ "c0@4:8@12r^{FSRef=[80C]}16r^{FSRef=[80C]}20@24i28", (superfunc)super_288, (IMP)meth_imp_288 },
	{ "c0@4:8@12r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}16", (superfunc)super_289, (IMP)meth_imp_289 },
	{ "c0@4:8@12r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}16i20", (superfunc)super_290, (IMP)meth_imp_290 },
	{ "c0@4:8@12{_NSPoint=ff}16", (superfunc)super_291, (IMP)meth_imp_291 },
	{ "c0@4:8@12{_NSRange=II}16", (superfunc)super_292, (IMP)meth_imp_292 },
	{ "c0@4:8@12{_NSRange=II}16@24", (superfunc)super_293, (IMP)meth_imp_293 },
	{ "c0@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16", (superfunc)super_294, (IMP)meth_imp_294 },
	{ "c0@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32", (superfunc)super_295, (IMP)meth_imp_295 },
	{ "c0@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16c32", (superfunc)super_296, (IMP)meth_imp_296 },
	{ "c0@4:8C12", (superfunc)super_297, (IMP)meth_imp_297 },
	{ "c0@4:8I12", (superfunc)super_298, (IMP)meth_imp_298 },
	{ "c0@4:8I12I16", (superfunc)super_299, (IMP)meth_imp_299 },
	{ "c0@4:8I12I16@20", (superfunc)super_300, (IMP)meth_imp_300 },
	{ "c0@4:8I12{_NSPoint=ff}16I24@28", (superfunc)super_301, (IMP)meth_imp_301 },
	{ "c0@4:8L12", (superfunc)super_302, (IMP)meth_imp_302 },
	{ "c0@4:8S12", (superfunc)super_303, (IMP)meth_imp_303 },
	{ "c0@4:8c12", (superfunc)super_304, (IMP)meth_imp_304 },
	{ "c0@4:8d40", (superfunc)super_305, (IMP)meth_imp_305 },
	{ "c0@4:8f40", (superfunc)super_306, (IMP)meth_imp_306 },
	{ "c0@4:8f40c16", (superfunc)super_307, (IMP)meth_imp_307 },
	{ "c0@4:8i12", (superfunc)super_308, (IMP)meth_imp_308 },
	{ "c0@4:8i12@16", (superfunc)super_309, (IMP)meth_imp_309 },
	{ "c0@4:8i12@16@20", (superfunc)super_310, (IMP)meth_imp_310 },
	{ "c0@4:8i12@16@20@24", (superfunc)super_311, (IMP)meth_imp_311 },
	{ "c0@4:8i12c16", (superfunc)super_312, (IMP)meth_imp_312 },
	{ "c0@4:8i12f40r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}20r^{_NSPoint=ff}24", (superfunc)super_313, (IMP)meth_imp_313 },
	{ "c0@4:8i12i16", (superfunc)super_314, (IMP)meth_imp_314 },
	{ "c0@4:8i12i16i20", (superfunc)super_315, (IMP)meth_imp_315 },
	{ "c0@4:8l12", (superfunc)super_316, (IMP)meth_imp_316 },
	{ "c0@4:8nO@12nO@16", (superfunc)super_317, (IMP)meth_imp_317 },
	{ "c0@4:8r*12", (superfunc)super_318, (IMP)meth_imp_318 },
	{ "c0@4:8r^{FSRef=[80C]}12", (superfunc)super_319, (IMP)meth_imp_319 },
	{ "c0@4:8r^{_NSPoint=ff}12", (superfunc)super_320, (IMP)meth_imp_320 },
	{ "c0@4:8r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@16", (superfunc)super_321, (IMP)meth_imp_321 },
	{ "c0@4:8r^{_NSRect={_NSPoint=ff}{_NSSize=ff}}12f40", (superfunc)super_322, (IMP)meth_imp_322 },
	{ "c0@4:8s12", (superfunc)super_323, (IMP)meth_imp_323 },
	{ "c0@4:8{NSButtonState=iccc}12", (superfunc)super_324, (IMP)meth_imp_324 },
	{ "c0@4:8{_NSPoint=ff}12", (superfunc)super_325, (IMP)meth_imp_325 },
	{ "c0@4:8{_NSPoint=ff}12@20", (superfunc)super_326, (IMP)meth_imp_326 },
	{ "c0@4:8{_NSPoint=ff}12i20", (superfunc)super_327, (IMP)meth_imp_327 },
	{ "c0@4:8{_NSPoint=ff}12{_NSPoint=ff}20@28", (superfunc)super_328, (IMP)meth_imp_328 },
	{ "c0@4:8{_NSPoint=ff}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}20", (superfunc)super_329, (IMP)meth_imp_329 },
	{ "c0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12", (superfunc)super_330, (IMP)meth_imp_330 },
	{ "c0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28", (superfunc)super_331, (IMP)meth_imp_331 },
	{ "c0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28@32", (superfunc)super_332, (IMP)meth_imp_332 },
	{ "c36@4:8@12i16i20c24c28c32c35", (superfunc)super_333, (IMP)meth_imp_333 },
	{ "c36@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32I32", (superfunc)super_334, (IMP)meth_imp_334 },
	{ "c36@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32c35", (superfunc)super_335, (IMP)meth_imp_335 },
	{ "c36@4:8{_NSRange=II}12{_NSRange=II}20{_NSRange=II}28@32", (superfunc)super_336, (IMP)meth_imp_336 },
	{ "c36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28i32i32", (superfunc)super_337, (IMP)meth_imp_337 },
	{ "c40@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32I32c39", (superfunc)super_338, (IMP)meth_imp_338 },
	{ "c40@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32c35@36", (superfunc)super_339, (IMP)meth_imp_339 },
	{ "c40@4:8d40@20@24@28@32I32I36", (superfunc)super_340, (IMP)meth_imp_340 },
	{ "c60@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}24i40f40c51c55c59", (superfunc)super_341, (IMP)meth_imp_341 },
	{ "c@:@o^@", (superfunc)super_342, (IMP)meth_imp_342 },
	{ "c@:@o^@o^@", (superfunc)super_343, (IMP)meth_imp_343 },
	{ "c@:o^@@o^@", (superfunc)super_344, (IMP)meth_imp_344 },
	{ "c@:o^I", (superfunc)super_345, (IMP)meth_imp_345 },
	{ "c@:o^d", (superfunc)super_346, (IMP)meth_imp_346 },
	{ "c@:o^f", (superfunc)super_347, (IMP)meth_imp_347 },
	{ "c@:o^i", (superfunc)super_348, (IMP)meth_imp_348 },
	{ "c@:o^q", (superfunc)super_349, (IMP)meth_imp_349 },
	{ "d0@4:8", (superfunc)super_350, (IMP)meth_imp_350 },
	{ "d0@4:8@12", (superfunc)super_351, (IMP)meth_imp_351 },
	{ "d0@4:8d40", (superfunc)super_352, (IMP)meth_imp_352 },
	{ "d0@4:8i12", (superfunc)super_353, (IMP)meth_imp_353 },
	{ "d0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12", (superfunc)super_354, (IMP)meth_imp_354 },
	{ "f0@4:8", (superfunc)super_355, (IMP)meth_imp_355 },
	{ "f0@4:8@12", (superfunc)super_356, (IMP)meth_imp_356 },
	{ "f0@4:8@12@16", (superfunc)super_357, (IMP)meth_imp_357 },
	{ "f0@4:8@12@16f40", (superfunc)super_358, (IMP)meth_imp_358 },
	{ "f0@4:8@12I16", (superfunc)super_359, (IMP)meth_imp_359 },
	{ "f0@4:8@12f40i20", (superfunc)super_360, (IMP)meth_imp_360 },
	{ "f0@4:8@12i16", (superfunc)super_361, (IMP)meth_imp_361 },
	{ "f0@4:8I12", (superfunc)super_362, (IMP)meth_imp_362 },
	{ "f0@4:8c12", (superfunc)super_363, (IMP)meth_imp_363 },
	{ "f0@4:8c12f40", (superfunc)super_364, (IMP)meth_imp_364 },
	{ "f0@4:8d40", (superfunc)super_365, (IMP)meth_imp_365 },
	{ "f0@4:8f40", (superfunc)super_366, (IMP)meth_imp_366 },
	{ "f0@4:8i12", (superfunc)super_367, (IMP)meth_imp_367 },
	{ "f0@4:8r*12I16", (superfunc)super_368, (IMP)meth_imp_368 },
	{ "f0@4:8{_NSPoint=ff}12@20", (superfunc)super_369, (IMP)meth_imp_369 },
	{ "f0@4:8{_NSSize=ff}12", (superfunc)super_370, (IMP)meth_imp_370 },
	{ "i0@4:8", (superfunc)super_371, (IMP)meth_imp_371 },
	{ "i0@4:8*12", (superfunc)super_372, (IMP)meth_imp_372 },
	{ "i0@4:8*12@16", (superfunc)super_373, (IMP)meth_imp_373 },
	{ "i0@4:8@12", (superfunc)super_374, (IMP)meth_imp_374 },
	{ "i0@4:8@12:16", (superfunc)super_375, (IMP)meth_imp_375 },
	{ "i0@4:8@12@16", (superfunc)super_376, (IMP)meth_imp_376 },
	{ "i0@4:8@12@16@20", (superfunc)super_377, (IMP)meth_imp_377 },
	{ "i0@4:8@12@16@20@24", (superfunc)super_378, (IMP)meth_imp_378 },
	{ "i0@4:8@12@16@20@24@28@32", (superfunc)super_379, (IMP)meth_imp_379 },
	{ "i0@4:8@12@16@20c24", (superfunc)super_380, (IMP)meth_imp_380 },
	{ "i0@4:8@12@16c20", (superfunc)super_381, (IMP)meth_imp_381 },
	{ "i0@4:8@12@16c20c24", (superfunc)super_382, (IMP)meth_imp_382 },
	{ "i0@4:8@12@16i20", (superfunc)super_383, (IMP)meth_imp_383 },
	{ "i0@4:8@12I16", (superfunc)super_384, (IMP)meth_imp_384 },
	{ "i0@4:8@12I16{_NSRange=II}20", (superfunc)super_385, (IMP)meth_imp_385 },
	{ "i0@4:8@12I16{_NSRange=II}20@28", (superfunc)super_386, (IMP)meth_imp_386 },
	{ "i0@4:8@12c16", (superfunc)super_387, (IMP)meth_imp_387 },
	{ "i0@4:8@12c16@20", (superfunc)super_388, (IMP)meth_imp_388 },
	{ "i0@4:8@12c16@20@24@28", (superfunc)super_389, (IMP)meth_imp_389 },
	{ "i0@4:8@12c16c20", (superfunc)super_390, (IMP)meth_imp_390 },
	{ "i0@4:8@12i16", (superfunc)super_391, (IMP)meth_imp_391 },
	{ "i0@4:8@12i16c20", (superfunc)super_392, (IMP)meth_imp_392 },
	{ "i0@4:8@12{_NSRange=II}16", (superfunc)super_393, (IMP)meth_imp_393 },
	{ "i0@4:8I12", (superfunc)super_394, (IMP)meth_imp_394 },
	{ "i0@4:8S12", (superfunc)super_395, (IMP)meth_imp_395 },
	{ "i0@4:8S12i16", (superfunc)super_396, (IMP)meth_imp_396 },
	{ "i0@4:8c12@16@20@24", (superfunc)super_397, (IMP)meth_imp_397 },
	{ "i0@4:8d40", (superfunc)super_398, (IMP)meth_imp_398 },
	{ "i0@4:8f40", (superfunc)super_399, (IMP)meth_imp_399 },
	{ "i0@4:8i12", (superfunc)super_400, (IMP)meth_imp_400 },
	{ "i0@4:8i12@16", (superfunc)super_401, (IMP)meth_imp_401 },
	{ "i0@4:8i12I16", (superfunc)super_402, (IMP)meth_imp_402 },
	{ "i0@4:8i12c16@20", (superfunc)super_403, (IMP)meth_imp_403 },
	{ "i0@4:8i12f40", (superfunc)super_404, (IMP)meth_imp_404 },
	{ "i0@4:8i12i16", (superfunc)super_405, (IMP)meth_imp_405 },
	{ "i0@4:8i12i16@20", (superfunc)super_406, (IMP)meth_imp_406 },
	{ "i0@4:8i12{_NSPoint=ff}16", (superfunc)super_407, (IMP)meth_imp_407 },
	{ "i0@4:8i12{_NSPoint=ff}16@24i28", (superfunc)super_408, (IMP)meth_imp_408 },
	{ "i0@4:8n@12", (superfunc)super_409, (IMP)meth_imp_409 },
	{ "i0@4:8r^{_NSPoint=ff}12", (superfunc)super_410, (IMP)meth_imp_410 },
	{ "i0@4:8{NSButtonState=iccc}12", (superfunc)super_411, (IMP)meth_imp_411 },
	{ "i0@4:8{_NSPoint=ff}12", (superfunc)super_412, (IMP)meth_imp_412 },
	{ "i0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12", (superfunc)super_413, (IMP)meth_imp_413 },
	{ "i36@4:8@12@16i20c24c28c32c35", (superfunc)super_414, (IMP)meth_imp_414 },
	{ "i36@4:8@12{_NSRange=II}16@24{_NSRange=II}28i32", (superfunc)super_415, (IMP)meth_imp_415 },
	{ "i40@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12c28@32@32@36", (superfunc)super_416, (IMP)meth_imp_416 },
	{ "i@:@", (superfunc)super_417, (IMP)meth_imp_417 },
	{ "l0@4:8", (superfunc)super_418, (IMP)meth_imp_418 },
	{ "l0@4:8i12r*16i20", (superfunc)super_419, (IMP)meth_imp_419 },
	{ "q0@4:8", (superfunc)super_420, (IMP)meth_imp_420 },
	{ "q0@4:8@12", (superfunc)super_421, (IMP)meth_imp_421 },
	{ "r*0@4:8", (superfunc)super_422, (IMP)meth_imp_422 },
	{ "r*0@4:8@12", (superfunc)super_423, (IMP)meth_imp_423 },
	{ "r*0@4:8I12", (superfunc)super_424, (IMP)meth_imp_424 },
	{ "r*0@4:8c12", (superfunc)super_425, (IMP)meth_imp_425 },
	{ "r^I0@4:8", (superfunc)super_426, (IMP)meth_imp_426 },
	{ "r^S0@4:8", (superfunc)super_427, (IMP)meth_imp_427 },
	{ "r^f0@4:8", (superfunc)super_428, (IMP)meth_imp_428 },
	{ "r^f0@4:8@12", (superfunc)super_429, (IMP)meth_imp_429 },
	{ "r^i0@4:8", (superfunc)super_430, (IMP)meth_imp_430 },
	{ "r^{AEDesc=I^^{OpaqueAEDataStorageType}}0@4:8", (superfunc)super_431, (IMP)meth_imp_431 },
	{ "r^{FSRef=[80C]}0@4:8", (superfunc)super_432, (IMP)meth_imp_432 },
	{ "s0@4:8", (superfunc)super_433, (IMP)meth_imp_433 },
	{ "s0@4:8@12", (superfunc)super_434, (IMP)meth_imp_434 },
	{ "s0@4:8@12@16", (superfunc)super_435, (IMP)meth_imp_435 },
	{ "s0@4:8@12@16@20", (superfunc)super_436, (IMP)meth_imp_436 },
	{ "s0@4:8L12@16", (superfunc)super_437, (IMP)meth_imp_437 },
	{ "s0@4:8L12@16@20", (superfunc)super_438, (IMP)meth_imp_438 },
	{ "v0@4:8", (superfunc)super_439, (IMP)meth_imp_439 },
	{ "v0@4:8#12", (superfunc)super_440, (IMP)meth_imp_440 },
	{ "v0@4:8#12@16", (superfunc)super_441, (IMP)meth_imp_441 },
	{ "v0@4:8*12", (superfunc)super_442, (IMP)meth_imp_442 },
	{ "v0@4:8*12I16", (superfunc)super_443, (IMP)meth_imp_443 },
	{ "v0@4:8:12", (superfunc)super_444, (IMP)meth_imp_444 },
	{ "v0@4:8:12@16", (superfunc)super_445, (IMP)meth_imp_445 },
	{ "v0@4:8:12@16@20", (superfunc)super_446, (IMP)meth_imp_446 },
	{ "v0@4:8:12@16@20I24@28", (superfunc)super_447, (IMP)meth_imp_447 },
	{ "v0@4:8:12@16@20i24@28", (superfunc)super_448, (IMP)meth_imp_448 },
	{ "v0@4:8:12@16c20", (superfunc)super_449, (IMP)meth_imp_449 },
	{ "v0@4:8:12@16c20@24", (superfunc)super_450, (IMP)meth_imp_450 },
	{ "v0@4:8:12@16d40", (superfunc)super_451, (IMP)meth_imp_451 },
	{ "v0@4:8:12@16d40@28", (superfunc)super_452, (IMP)meth_imp_452 },
	{ "v0@4:8:12i16i20", (superfunc)super_453, (IMP)meth_imp_453 },
	{ "v0@4:8@12", (superfunc)super_454, (IMP)meth_imp_454 },
	{ "v0@4:8@12#16", (superfunc)super_455, (IMP)meth_imp_455 },
	{ "v0@4:8@12:16", (superfunc)super_456, (IMP)meth_imp_456 },
	{ "v0@4:8@12:16#20", (superfunc)super_457, (IMP)meth_imp_457 },
	{ "v0@4:8@12:16#20#24", (superfunc)super_458, (IMP)meth_imp_458 },
	{ "v0@4:8@12:16@20", (superfunc)super_459, (IMP)meth_imp_459 },
	{ "v0@4:8@12:16@20@24", (superfunc)super_460, (IMP)meth_imp_460 },
	{ "v0@4:8@12:16@20@24I28", (superfunc)super_461, (IMP)meth_imp_461 },
	{ "v0@4:8@12:16@20@24i28", (superfunc)super_462, (IMP)meth_imp_462 },
	{ "v0@4:8@12:16I20", (superfunc)super_463, (IMP)meth_imp_463 },
	{ "v0@4:8@12:16I20I24", (superfunc)super_464, (IMP)meth_imp_464 },
	{ "v0@4:8@12@16", (superfunc)super_465, (IMP)meth_imp_465 },
	{ "v0@4:8@12@16*20", (superfunc)super_466, (IMP)meth_imp_466 },
	{ "v0@4:8@12@16@20", (superfunc)super_467, (IMP)meth_imp_467 },
	{ "v0@4:8@12@16@20@24", (superfunc)super_468, (IMP)meth_imp_468 },
	{ "v0@4:8@12@16@20@24@28@32", (superfunc)super_469, (IMP)meth_imp_469 },
	{ "v0@4:8@12@16@20@24c28", (superfunc)super_470, (IMP)meth_imp_470 },
	{ "v0@4:8@12@16@20I24", (superfunc)super_471, (IMP)meth_imp_471 },
	{ "v0@4:8@12@16@20I24@28", (superfunc)super_472, (IMP)meth_imp_472 },
	{ "v0@4:8@12@16@20c24", (superfunc)super_473, (IMP)meth_imp_473 },
	{ "v0@4:8@12@16@20i24", (superfunc)super_474, (IMP)meth_imp_474 },
	{ "v0@4:8@12@16@20i24c28", (superfunc)super_475, (IMP)meth_imp_475 },
	{ "v0@4:8@12@16I20", (superfunc)super_476, (IMP)meth_imp_476 },
	{ "v0@4:8@12@16I20@24", (superfunc)super_477, (IMP)meth_imp_477 },
	{ "v0@4:8@12@16L20", (superfunc)super_478, (IMP)meth_imp_478 },
	{ "v0@4:8@12@16c20", (superfunc)super_479, (IMP)meth_imp_479 },
	{ "v0@4:8@12@16c20c24", (superfunc)super_480, (IMP)meth_imp_480 },
	{ "v0@4:8@12@16f40@24@28", (superfunc)super_481, (IMP)meth_imp_481 },
	{ "v0@4:8@12@16i20", (superfunc)super_482, (IMP)meth_imp_482 },
	{ "v0@4:8@12@16i20@24", (superfunc)super_483, (IMP)meth_imp_483 },
	{ "v0@4:8@12@16i20i24", (superfunc)super_484, (IMP)meth_imp_484 },
	{ "v0@4:8@12@16l20@24", (superfunc)super_485, (IMP)meth_imp_485 },
	{ "v0@4:8@12@16{_NSRange=II}20", (superfunc)super_486, (IMP)meth_imp_486 },
	{ "v0@4:8@12@16{_NSRect={_NSPoint=ff}{_NSSize=ff}}20", (superfunc)super_487, (IMP)meth_imp_487 },
	{ "v0@4:8@12I16", (superfunc)super_488, (IMP)meth_imp_488 },
	{ "v0@4:8@12I16@20", (superfunc)super_489, (IMP)meth_imp_489 },
	{ "v0@4:8@12I16@20*24", (superfunc)super_490, (IMP)meth_imp_490 },
	{ "v0@4:8@12L16", (superfunc)super_491, (IMP)meth_imp_491 },
	{ "v0@4:8@12c16", (superfunc)super_492, (IMP)meth_imp_492 },
	{ "v0@4:8@12c16c20", (superfunc)super_493, (IMP)meth_imp_493 },
	{ "v0@4:8@12c16c20c24", (superfunc)super_494, (IMP)meth_imp_494 },
	{ "v0@4:8@12c16i20i24", (superfunc)super_495, (IMP)meth_imp_495 },
	{ "v0@4:8@12d40", (superfunc)super_496, (IMP)meth_imp_496 },
	{ "v0@4:8@12f40", (superfunc)super_497, (IMP)meth_imp_497 },
	{ "v0@4:8@12f40f48c24", (superfunc)super_498, (IMP)meth_imp_498 },
	{ "v0@4:8@12i16", (superfunc)super_499, (IMP)meth_imp_499 },
	{ "v0@4:8@12i16@20", (superfunc)super_500, (IMP)meth_imp_500 },
	{ "v0@4:8@12i16I20", (superfunc)super_501, (IMP)meth_imp_501 },
	{ "v0@4:8@12i16I20@24", (superfunc)super_502, (IMP)meth_imp_502 },
	{ "v0@4:8@12i16c20c24c28", (superfunc)super_503, (IMP)meth_imp_503 },
	{ "v0@4:8@12i16d40", (superfunc)super_504, (IMP)meth_imp_504 },
	{ "v0@4:8@12i16f40", (superfunc)super_505, (IMP)meth_imp_505 },
	{ "v0@4:8@12i16i20", (superfunc)super_506, (IMP)meth_imp_506 },
	{ "v0@4:8@12i16i20i24c28", (superfunc)super_507, (IMP)meth_imp_507 },
	{ "v0@4:8@12i16{_NSRange=II}20", (superfunc)super_508, (IMP)meth_imp_508 },
	{ "v0@4:8@12i16{_NSRect={_NSPoint=ff}{_NSSize=ff}}20", (superfunc)super_509, (IMP)meth_imp_509 },
	{ "v0@4:8@12l16", (superfunc)super_510, (IMP)meth_imp_510 },
	{ "v0@4:8@12s16", (superfunc)super_511, (IMP)meth_imp_511 },
	{ "v0@4:8@12{_NSPoint=ff}16", (superfunc)super_512, (IMP)meth_imp_512 },
	{ "v0@4:8@12{_NSPoint=ff}16I24", (superfunc)super_513, (IMP)meth_imp_513 },
	{ "v0@4:8@12{_NSPoint=ff}16{_NSPoint=ff}24", (superfunc)super_514, (IMP)meth_imp_514 },
	{ "v0@4:8@12{_NSRange=II}16", (superfunc)super_515, (IMP)meth_imp_515 },
	{ "v0@4:8@12{_NSRange=II}16@24", (superfunc)super_516, (IMP)meth_imp_516 },
	{ "v0@4:8@12{_NSRange=II}16c24", (superfunc)super_517, (IMP)meth_imp_517 },
	{ "v0@4:8@12{_NSRange=II}16{_NSRange=II}24", (superfunc)super_518, (IMP)meth_imp_518 },
	{ "v0@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16", (superfunc)super_519, (IMP)meth_imp_519 },
	{ "v0@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32", (superfunc)super_520, (IMP)meth_imp_520 },
	{ "v0@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16c32", (superfunc)super_521, (IMP)meth_imp_521 },
	{ "v0@4:8@12{_NSSize=ff}16", (superfunc)super_522, (IMP)meth_imp_522 },
	{ "v0@4:8C12", (superfunc)super_523, (IMP)meth_imp_523 },
	{ "v0@4:8I12", (superfunc)super_524, (IMP)meth_imp_524 },
	{ "v0@4:8I12@16", (superfunc)super_525, (IMP)meth_imp_525 },
	{ "v0@4:8I12@16@20", (superfunc)super_526, (IMP)meth_imp_526 },
	{ "v0@4:8I12I16", (superfunc)super_527, (IMP)meth_imp_527 },
	{ "v0@4:8I12I16I20", (superfunc)super_528, (IMP)meth_imp_528 },
	{ "v0@4:8I12Q16", (superfunc)super_529, (IMP)meth_imp_529 },
	{ "v0@4:8I12{_NSPoint=ff}16I24@28", (superfunc)super_530, (IMP)meth_imp_530 },
	{ "v0@4:8I12{_NSRange=II}16", (superfunc)super_531, (IMP)meth_imp_531 },
	{ "v0@4:8I12{_NSRange=II}16i24", (superfunc)super_532, (IMP)meth_imp_532 },
	{ "v0@4:8I12{_NSRange=II}16i24{_NSRange=II}28", (superfunc)super_533, (IMP)meth_imp_533 },
	{ "v0@4:8L12", (superfunc)super_534, (IMP)meth_imp_534 },
	{ "v0@4:8L12@16L20", (superfunc)super_535, (IMP)meth_imp_535 },
	{ "v0@4:8Q12", (superfunc)super_536, (IMP)meth_imp_536 },
	{ "v0@4:8S12", (superfunc)super_537, (IMP)meth_imp_537 },
	{ "v0@4:8S12I16", (superfunc)super_538, (IMP)meth_imp_538 },
	{ "v0@4:8c12", (superfunc)super_539, (IMP)meth_imp_539 },
	{ "v0@4:8c12@16", (superfunc)super_540, (IMP)meth_imp_540 },
	{ "v0@4:8c12@16@20@24", (superfunc)super_541, (IMP)meth_imp_541 },
	{ "v0@4:8c12I16", (superfunc)super_542, (IMP)meth_imp_542 },
	{ "v0@4:8c12I16I20", (superfunc)super_543, (IMP)meth_imp_543 },
	{ "v0@4:8c12c16", (superfunc)super_544, (IMP)meth_imp_544 },
	{ "v0@4:8c12c16c20", (superfunc)super_545, (IMP)meth_imp_545 },
	{ "v0@4:8c12f40", (superfunc)super_546, (IMP)meth_imp_546 },
	{ "v0@4:8c12i16i20", (superfunc)super_547, (IMP)meth_imp_547 },
	{ "v0@4:8c12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16", (superfunc)super_548, (IMP)meth_imp_548 },
	{ "v0@4:8c12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32", (superfunc)super_549, (IMP)meth_imp_549 },
	{ "v0@4:8d40", (superfunc)super_550, (IMP)meth_imp_550 },
	{ "v0@4:8d40@20", (superfunc)super_551, (IMP)meth_imp_551 },
	{ "v0@4:8d40c20", (superfunc)super_552, (IMP)meth_imp_552 },
	{ "v0@4:8d40d48", (superfunc)super_553, (IMP)meth_imp_553 },
	{ "v0@4:8f40", (superfunc)super_554, (IMP)meth_imp_554 },
	{ "v0@4:8f40@16", (superfunc)super_555, (IMP)meth_imp_555 },
	{ "v0@4:8f40@16@20@24", (superfunc)super_556, (IMP)meth_imp_556 },
	{ "v0@4:8f40c16", (superfunc)super_557, (IMP)meth_imp_557 },
	{ "v0@4:8f40f48", (superfunc)super_558, (IMP)meth_imp_558 },
	{ "v0@4:8i12", (superfunc)super_559, (IMP)meth_imp_559 },
	{ "v0@4:8i12@16", (superfunc)super_560, (IMP)meth_imp_560 },
	{ "v0@4:8i12@16:20i24i28", (superfunc)super_561, (IMP)meth_imp_561 },
	{ "v0@4:8i12I16", (superfunc)super_562, (IMP)meth_imp_562 },
	{ "v0@4:8i12c16", (superfunc)super_563, (IMP)meth_imp_563 },
	{ "v0@4:8i12c16c20", (superfunc)super_564, (IMP)meth_imp_564 },
	{ "v0@4:8i12c16c20c24", (superfunc)super_565, (IMP)meth_imp_565 },
	{ "v0@4:8i12f40", (superfunc)super_566, (IMP)meth_imp_566 },
	{ "v0@4:8i12f40f48f56", (superfunc)super_567, (IMP)meth_imp_567 },
	{ "v0@4:8i12i16", (superfunc)super_568, (IMP)meth_imp_568 },
	{ "v0@4:8i12i16@20", (superfunc)super_569, (IMP)meth_imp_569 },
	{ "v0@4:8i12i16@20c24", (superfunc)super_570, (IMP)meth_imp_570 },
	{ "v0@4:8i12i16I20", (superfunc)super_571, (IMP)meth_imp_571 },
	{ "v0@4:8i12i16c20", (superfunc)super_572, (IMP)meth_imp_572 },
	{ "v0@4:8i12i16c20c24c28", (superfunc)super_573, (IMP)meth_imp_573 },
	{ "v0@4:8i12i16c20c24c28c32", (superfunc)super_574, (IMP)meth_imp_574 },
	{ "v0@4:8i12i16f40", (superfunc)super_575, (IMP)meth_imp_575 },
	{ "v0@4:8i12i16i20", (superfunc)super_576, (IMP)meth_imp_576 },
	{ "v0@4:8i12i16i20c24", (superfunc)super_577, (IMP)meth_imp_577 },
	{ "v0@4:8i12r*16i20", (superfunc)super_578, (IMP)meth_imp_578 },
	{ "v0@4:8i12{_NSRange=II}16", (superfunc)super_579, (IMP)meth_imp_579 },
	{ "v0@4:8i12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16", (superfunc)super_580, (IMP)meth_imp_580 },
	{ "v0@4:8l12", (superfunc)super_581, (IMP)meth_imp_581 },
	{ "v0@4:8q12@20", (superfunc)super_582, (IMP)meth_imp_582 },
	{ "v0@4:8r*12", (superfunc)super_583, (IMP)meth_imp_583 },
	{ "v0@4:8r*12I16@20", (superfunc)super_584, (IMP)meth_imp_584 },
	{ "v0@4:8r*12i16", (superfunc)super_585, (IMP)meth_imp_585 },
	{ "v0@4:8r*12{_NSPoint=ff}16", (superfunc)super_586, (IMP)meth_imp_586 },
	{ "v0@4:8r^S12I16", (superfunc)super_587, (IMP)meth_imp_587 },
	{ "v0@4:8r^f12f40", (superfunc)super_588, (IMP)meth_imp_588 },
	{ "v0@4:8r^f12i16f40", (superfunc)super_589, (IMP)meth_imp_589 },
	{ "v0@4:8r^i12i16", (superfunc)super_590, (IMP)meth_imp_590 },
	{ "v0@4:8r^{_NSPoint=ff}12@16", (superfunc)super_591, (IMP)meth_imp_591 },
	{ "v0@4:8{?=ii}12", (superfunc)super_592, (IMP)meth_imp_592 },
	{ "v0@4:8{_NSAffineTransformStruct=ffffff}12", (superfunc)super_593, (IMP)meth_imp_593 },
	{ "v0@4:8{_NSPoint=ff}12", (superfunc)super_594, (IMP)meth_imp_594 },
	{ "v0@4:8{_NSPoint=ff}12@20", (superfunc)super_595, (IMP)meth_imp_595 },
	{ "v0@4:8{_NSPoint=ff}12d40", (superfunc)super_596, (IMP)meth_imp_596 },
	{ "v0@4:8{_NSPoint=ff}12d40d48d56", (superfunc)super_597, (IMP)meth_imp_597 },
	{ "v0@4:8{_NSPoint=ff}12f40", (superfunc)super_598, (IMP)meth_imp_598 },
	{ "v0@4:8{_NSPoint=ff}12f40f48f56", (superfunc)super_599, (IMP)meth_imp_599 },
	{ "v0@4:8{_NSPoint=ff}12f40f48f56c32", (superfunc)super_600, (IMP)meth_imp_600 },
	{ "v0@4:8{_NSPoint=ff}12i20", (superfunc)super_601, (IMP)meth_imp_601 },
	{ "v0@4:8{_NSPoint=ff}12i20f40", (superfunc)super_602, (IMP)meth_imp_602 },
	{ "v0@4:8{_NSPoint=ff}12{_NSPoint=ff}20", (superfunc)super_603, (IMP)meth_imp_603 },
	{ "v0@4:8{_NSPoint=ff}12{_NSPoint=ff}20@28", (superfunc)super_604, (IMP)meth_imp_604 },
	{ "v0@4:8{_NSPoint=ff}12{_NSPoint=ff}20@28c32", (superfunc)super_605, (IMP)meth_imp_605 },
	{ "v0@4:8{_NSPoint=ff}12{_NSPoint=ff}20f40", (superfunc)super_606, (IMP)meth_imp_606 },
	{ "v0@4:8{_NSPoint=ff}12{_NSPoint=ff}20{_NSPoint=ff}28", (superfunc)super_607, (IMP)meth_imp_607 },
	{ "v0@4:8{_NSPoint=ff}12{_NSRange=II}20", (superfunc)super_608, (IMP)meth_imp_608 },
	{ "v0@4:8{_NSPoint=ff}12{_NSRange=II}20c28", (superfunc)super_609, (IMP)meth_imp_609 },
	{ "v0@4:8{_NSPoint=ff}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}20f40", (superfunc)super_610, (IMP)meth_imp_610 },
	{ "v0@4:8{_NSRange=II}12", (superfunc)super_611, (IMP)meth_imp_611 },
	{ "v0@4:8{_NSRange=II}12@20", (superfunc)super_612, (IMP)meth_imp_612 },
	{ "v0@4:8{_NSRange=II}12@20I24", (superfunc)super_613, (IMP)meth_imp_613 },
	{ "v0@4:8{_NSRange=II}12@20{_NSRange=II}24", (superfunc)super_614, (IMP)meth_imp_614 },
	{ "v0@4:8{_NSRange=II}12c20", (superfunc)super_615, (IMP)meth_imp_615 },
	{ "v0@4:8{_NSRange=II}12i20c24", (superfunc)super_616, (IMP)meth_imp_616 },
	{ "v0@4:8{_NSRange=II}12r*20I24", (superfunc)super_617, (IMP)meth_imp_617 },
	{ "v0@4:8{_NSRange=II}12r^S20I24", (superfunc)super_618, (IMP)meth_imp_618 },
	{ "v0@4:8{_NSRange=II}12{_NSRange=II}20", (superfunc)super_619, (IMP)meth_imp_619 },
	{ "v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12", (superfunc)super_620, (IMP)meth_imp_620 },
	{ "v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28", (superfunc)super_621, (IMP)meth_imp_621 },
	{ "v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28@32", (superfunc)super_622, (IMP)meth_imp_622 },
	{ "v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28I32", (superfunc)super_623, (IMP)meth_imp_623 },
	{ "v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28c32", (superfunc)super_624, (IMP)meth_imp_624 },
	{ "v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28i32", (superfunc)super_625, (IMP)meth_imp_625 },
	{ "v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12c28", (superfunc)super_626, (IMP)meth_imp_626 },
	{ "v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12c28@32", (superfunc)super_627, (IMP)meth_imp_627 },
	{ "v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12c28c32", (superfunc)super_628, (IMP)meth_imp_628 },
	{ "v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12f40", (superfunc)super_629, (IMP)meth_imp_629 },
	{ "v0@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSSize=ff}28", (superfunc)super_630, (IMP)meth_imp_630 },
	{ "v0@4:8{_NSSize=ff}12", (superfunc)super_631, (IMP)meth_imp_631 },
	{ "v0@4:8{_NSSize=ff}12c20", (superfunc)super_632, (IMP)meth_imp_632 },
	{ "v0@4:8{_NSSize=ff}12c20c24", (superfunc)super_633, (IMP)meth_imp_633 },
	{ "v0@4:8{_NSSize=ff}12c20{_NSSize=ff}24c32", (superfunc)super_634, (IMP)meth_imp_634 },
	{ "v0@4:8{_NSSize=ff}12{_NSRange=II}20", (superfunc)super_635, (IMP)meth_imp_635 },
	{ "v104@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}24{_NSRect={_NSPoint=ff}{_NSSize=ff}}40{_NSRect={_NSPoint=ff}{_NSSize=ff}}56{_NSRect={_NSPoint=ff}{_NSSize=ff}}72{_NSRect={_NSPoint=ff}{_NSSize=ff}}88", (superfunc)super_636, (IMP)meth_imp_636 },
	{ "v36@4:8@12@16@20@24@28@32c35", (superfunc)super_637, (IMP)meth_imp_637 },
	{ "v36@4:8@12I16{_NSRange=II}20i28{_NSRange=II}28", (superfunc)super_638, (IMP)meth_imp_638 },
	{ "v36@4:8@12{_NSPoint=ff}16f40@28i32@32", (superfunc)super_639, (IMP)meth_imp_639 },
	{ "v36@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32c35", (superfunc)super_640, (IMP)meth_imp_640 },
	{ "v36@4:8c12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32@32", (superfunc)super_641, (IMP)meth_imp_641 },
	{ "v36@4:8i12i16i20{_NSRect={_NSPoint=ff}{_NSSize=ff}}20", (superfunc)super_642, (IMP)meth_imp_642 },
	{ "v36@4:8{_NSPoint=ff}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}20i32", (superfunc)super_643, (IMP)meth_imp_643 },
	{ "v36@4:8{_NSPoint=ff}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}20i32f40", (superfunc)super_644, (IMP)meth_imp_644 },
	{ "v36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28@32@32", (superfunc)super_645, (IMP)meth_imp_645 },
	{ "v36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28I32@32", (superfunc)super_646, (IMP)meth_imp_646 },
	{ "v36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28c32i32", (superfunc)super_647, (IMP)meth_imp_647 },
	{ "v36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28i32i32", (superfunc)super_648, (IMP)meth_imp_648 },
	{ "v36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12I28i32c35", (superfunc)super_649, (IMP)meth_imp_649 },
	{ "v36@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12c28@32c35", (superfunc)super_650, (IMP)meth_imp_650 },
	{ "v40@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16@32I32@36", (superfunc)super_651, (IMP)meth_imp_651 },
	{ "v40@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16c32@32c39", (superfunc)super_652, (IMP)meth_imp_652 },
	{ "v40@4:8{_NSPoint=ff}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}20c35c39", (superfunc)super_653, (IMP)meth_imp_653 },
	{ "v40@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28@32@32@36", (superfunc)super_654, (IMP)meth_imp_654 },
	{ "v40@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}24", (superfunc)super_655, (IMP)meth_imp_655 },
	{ "v44@4:8@12{_NSPoint=ff}16{_NSSize=ff}24@32@32@36c43", (superfunc)super_656, (IMP)meth_imp_656 },
	{ "v44@4:8@12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16{_NSRect={_NSPoint=ff}{_NSSize=ff}}28", (superfunc)super_657, (IMP)meth_imp_657 },
	{ "v44@4:8f40{_NSPoint=ff}16{_NSPoint=ff}24{_NSPoint=ff}28{_NSPoint=ff}36", (superfunc)super_658, (IMP)meth_imp_658 },
	{ "v44@4:8i12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16{_NSRect={_NSPoint=ff}{_NSSize=ff}}28", (superfunc)super_659, (IMP)meth_imp_659 },
	{ "v44@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12@28@32@32i36i40", (superfunc)super_660, (IMP)meth_imp_660 },
	{ "v44@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}24@40", (superfunc)super_661, (IMP)meth_imp_661 },
	{ "v44@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}24c43", (superfunc)super_662, (IMP)meth_imp_662 },
	{ "v44@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}24i40f40", (superfunc)super_663, (IMP)meth_imp_663 },
	{ "v48@4:8@12@16{_NSPoint=ff}20{_NSSize=ff}28@32@36@40c47", (superfunc)super_664, (IMP)meth_imp_664 },
	{ "v48@4:8@12@16{_NSRect={_NSPoint=ff}{_NSSize=ff}}20{_NSRect={_NSPoint=ff}{_NSSize=ff}}32f40", (superfunc)super_665, (IMP)meth_imp_665 },
	{ "v48@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRange=II}28{_NSRect={_NSPoint=ff}{_NSSize=ff}}32", (superfunc)super_666, (IMP)meth_imp_666 },
	{ "v48@4:8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12{_NSRect={_NSPoint=ff}{_NSSize=ff}}24c43c47", (superfunc)super_667, (IMP)meth_imp_667 },
	{ "v52@4:8i12{_NSRect={_NSPoint=ff}{_NSSize=ff}}16{_NSRect={_NSPoint=ff}{_NSSize=ff}}28c47i48", (superfunc)super_668, (IMP)meth_imp_668 },
	{ "v52@4:8{_NSRange=II}12r^{ATSGlyphVector=III^v*I^v^{ATSStyleSetting}SsiiI{FixedRect=iiii}IiiiSS^S^s^s^i^i}20{_NSPoint=ff}24c32{_NSRect={_NSPoint=ff}{_NSSize=ff}}32c51", (superfunc)super_669, (IMP)meth_imp_669 },
	{ "v@:", (superfunc)super_670, (IMP)meth_imp_670 },
	{ "v@:@", (superfunc)super_671, (IMP)meth_imp_671 },
	{ "v@:@@", (superfunc)super_672, (IMP)meth_imp_672 },
	{ "v@:@@@", (superfunc)super_673, (IMP)meth_imp_673 },
	{ "v@:@@@@", (superfunc)super_674, (IMP)meth_imp_674 },
	{ "v@:@@@@@", (superfunc)super_675, (IMP)meth_imp_675 },
	{ "v@:@@@@@@", (superfunc)super_676, (IMP)meth_imp_676 },
	{ "v@:@@@@@@@", (superfunc)super_677, (IMP)meth_imp_677 },
	{ "c@:o^@@o^@", (superfunc)super_678, (IMP)meth_imp_678 },
	{ "v@:@@o^@", (superfunc)super_679, (IMP)meth_imp_679 },
	{0, 0}
};

int ObjC_RegisterStdStubs(struct pyobjc_api* api)
{
	struct method_table* cur = method_table;

	ObjC_API = api;


	while (cur->signature) {
		if (ObjC_RegisterSignatureMapping(
				cur->signature,
				cur->call_super,
				cur->implementation) < 0) {
			return -1;
		}
		cur ++;
	}
	return 0;
}

#endif

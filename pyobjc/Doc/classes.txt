===================================
Python classes and Objective-C code
===================================

.. This file is formatted using the rules for StructuredText

.. Version 0.1

Introduction
------------

PyObjC is a proxy between Objective-C and Python and allows access to Python
classes from Objective-C and vice versa. PyObjC also allows you to subclass
Objective-C classes from Python. 

Accessing Python objects from Objective-C
-----------------------------------------

All Python objects can be accessed from Objective-C through proxy objects. 
Whenever a Python object crosses the line from Python to Objective-C a proxy
object is created (of class OC_PythonObject, a subclass of NSProxy). This
proxy object will forward all method calls from Objective-C to python, and
will return the results back to Objective-C.

See the section 'Method protocol' for a description of how PyObjC translates 
between Python and Objective-C method calls.

Other than being a plain proxy the OC_PythonObject class also provides an
Objective-C flavored version of the Python C-API. 

.. Is anyone actually using the Objective-C version of the Python C-API?

A number of Python types/classes are treated specially:
- Python numbers are translated into NSNumber instances
- Python strings and unicode objects are translated into NSString instances
- Python dictionaries are proxied using OC_PythonDictionary, a subclass of NSMutableDictionary. This allows you to use a Python dictionary everywhere where an NSDictionary is expected.
- Python lists or tuples are proxied using OC_PythonArray, a subclas of NSMutableArray. This allows you to use a Python list or tuple everywhere where an NSArray is expected.

The special cases allow for more transparent bridging between Python and
Objective-C.

Accessing Objective-C objects from Python
-----------------------------------------

Objective-C objects are accessed through proxy objects that forward method
calls from Python to Objective-C. All proxy objects are instances of 
objc.objc_object, or a subclass of this class.

See the section 'Method protocol' for a description of how PyObjC translates 
between Python and Objective-C method calls.

The only Objective-C class that is not proxied is NSString, instances of this
class are translated to Python strings or unicode objects (depending on the
value of the string).

Accessing Objective-C classes from Python
-----------------------------------------

Objective-C classes are also accessed through proxy objects, but those are
subclasses of objc.objc_class. The proxies for Objective-C classes are 
classes in Python. 

Instances are created by calling allocator class methods (like 'alloc' or
factory methods). Objective-C instances cannot be created by using the class
as a factory function.

It is possible to create subclasses from Objective-C classes using the normal
mechanism. There are some limitations though:

1. The Objective-C class must be the first base class
2. There can be only 1 Objective-C base class.
   It is not possible to multiple-inherit from two Objective-C classes, this
   limitation is inherited from Objective-C.
3. It is not possible to overide or extend an Objective-C method using a mixin.
   This is limitation will be lifted in future versions of PyObjC.
4. It is not possible to overide or extend an Objective-C method by adding a new method to the class after creating it.

PyObjC provides limited support for Objective-C protocols. The type 
obc.informal_protocol can be used to shadow protocol definitions in Objective-C.
Instances of this type can be used as a superclass when defining a subclass of
an existing Objective-C class. The information in an 'informal_protocol' object
will be used to check if the new class does implement the protocol, and to
provide information to the bridge that is needed to correctly forward methods.

A subclass of an Objective-C (proxy) class is not only a Python class, but also
an Objective-C class. This means that it is possible to create instances of 
these classes from Objective-C using normal Objective-C syntax, although you
must locate the class using the function 'objc_lookUpClass' (e.g. defining
@class MyPythonClass will not work). One of the results of this feature is that
these classes can be used to implement classes that are defined in Interface
Builder NIB files.

Like Python classes Objective-C classes can have instance variables. If you
define new instance variables in the Python subclass they will only be visible
in Python, and not in Objective-C. This means that normal Python instance
variables cannot be used as 'outlets' in interface builder. Those can be 
defined using special properties: objc.instance_variable or objc.IBOutlet.

The Objective-C class::

  @interface MyClass : NSObject
  {
    IBOutlet id my_outlet1;
    IBOutlet id my_outlet2;
  }

  // ...
  @end // MyClass

can be defined in Python like this::

  class MyClass (NSObject):
    my_outlet1 = objc.IBOutlet('my_outlet1')
    my_outlet2 = objc.IBOutlet('my_outlet2')

  # ...

Method protocol
---------------

There is a straightforward translation from Objective-C method names to
Python method names: Concatenate all parts of the Objective-C method name
(without any whitespace) and then replace all colons by underscores.

Examples::

  (void)myAction:(id)sender	<->	def `myAction_`(self, sender)
  method:(int)x andY:y		<->	def `method_andY_`(self, x, y)

As can be seen in the examples above, Objective-C allows you to specify
the types of arguments and the return value, while this is not possible in
Python. This is not a problem when calling existing Objective-C methods, 
because PyObjC will automaticly read the needed information from the 
Objective-C runtime, but it can be a problem when defining new Objective-C
methods in Python.

PyObjC therefore provides a function to define the signature of a python method
in subclasses of Objective-C classes. This function, objc.selector, should be
used whenever you define a method that does not extend or override an existing
Objective-C method in the superclass. 

The following Objective-C class:

	@interface MyClass : NSObject
	{
	}

	-(int)methodWithX:(int)x andY:(float)y;
	-(void)myAction:(id)sender;

can be defined in Python like this:

::

	class MyClass (NSObject):

		def `methodWithX_andY_`(self, x, y):
			pass

		`methodWithX_and_Y_` = selector(`methodWithX_andY_`,
			signature='i@:if')

		def `myAction_`(self, sender):
			pass

		myAction_ = selector(`myAction_`,
			signature='v@:')

The explicit selectors don't really help to increase readability, especially
given the cryptic signature strings. It is therefore advisable to use other
methods to define the signature if possible, the most likely way to do this
is by using existing objc.informal_protocol definitions (like 
AppKit.NSOutlineViewDataSource). 

There is one instance where you don't have to define the signature: The default
signature is for a method that returns and object and where all arguments are
also objects.
